/*! Â© 2022 imaoki | MIT License | https://github.com/imaoki */;global standardDefinitionPool = Dictionary #String;global mxsDotNetTimerTickHandler = fn mxsDotNetTimerTickHandler sender event = (if classOf sender == DotNetObject and (DotNet.GetType "System.Windows.Forms.Timer").IsInstanceOfType sender do (if classOf sender.Tag == DotNetMxsValue do (local timerObject = sender.Tag.Value;if isStruct timerObject and isProperty timerObject #StructName and classOf timerObject.StructName == MAXScriptFunction and timerObject.StructName() == #TimerStruct do (timerObject.UpdateTicks(););););ok;);::standardDefinitionPool[@"AttributeUtility.ms"] = struct AttributeUtilityStruct (public fn GetAttribute obj attributeName = (local attribute = undefined;if isValidObj obj do (local attributeCount = CustAttributes.Count obj baseObject:true;for i = 1 to attributeCount while attribute == undefined do (if (CustAttributes.GetDef obj i baseObject:true).Name == attributeName do (attribute = CustAttributes.Get obj i baseObject:true;);););attribute;),public fn GetAttributeNames obj = (local attributeNames = #();if isValidObj obj do (local attributeDefs = CustAttributes.GetDefs obj baseObject:true;if classOf attributeDefs == Array do (attributeNames = for def in attributeDefs collect def.Name;););attributeNames;),public fn HasAttribute obj attributeName = (this.IsAttribute (this.GetAttribute obj attributeName);),public fn IsAttribute obj = (superClassOf obj == AttributeDef;),public fn StructName = #AttributeUtilityStruct,public fn Dump indent:"" out:listener = (format "%AttributeUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Comparer.ms"] = struct ComparerStruct (private stringLogicalComparer,public fn CompareName a b = (if classOf a.Name == String and classOf b.Name == String then (this.CompareStringLogical a.Name b.Name;);else (this.simpleCompare a.Name b.Name;);),public fn CompareNodeHandle a b = (this.simpleCompare a.INode.Handle b.INode.Handle;),public fn CompareProperty a b propName: = (local aValue = getProperty a propName;local bValue = getProperty b propName;if classOf aValue == String and classOf bValue == String then (this.CompareStringLogical aValue bValue;);else (this.simpleCompare aValue bValue;);),public fn CompareStringLogical a b = (this.stringLogicalComparer a b;),private fn simpleCompare a b = (case of ((a < b): -1;(a > b): 1;default: 0;);),public fn StructName = #ComparerStruct,public fn Dump indent:"" out:listener = (format "%ComparerStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.stringLogicalComparer = (local code = StringStream "";format "using System;\n" to:code;format "using System.Collections;\n" to:code;format "using System.Runtime.InteropServices;\n" to:code;format "public sealed class StringLogicalComparer : IComparer {\n" to:code;format "  [DllImport(\"shlwapi.dll\", CharSet = CharSet.Unicode, ExactSpelling = true)]\n" to:code;format "  static extern int StrCmpLogicalW(String a, String b);\n" to:code;format "  public int Compare(object a, object b) {\n" to:code;format "    return StrCmpLogicalW((String)a, (String)b);\n" to:code;format "  }\n" to:code;format "}" to:code;code = code as String;local provider = DotNetObject "Microsoft.CSharp.CSharpCodeProvider";local params = DotNetObject "System.CodeDom.Compiler.CompilerParameters";params.GenerateInMemory = true;local compilerResults = provider.CompileAssemblyFromSource params #(code);local assembly = compilerResults.CompiledAssembly;(assembly.CreateInstance "StringLogicalComparer").Compare;);););::standardDefinitionPool[@"DotNetUtility.ms"] = struct DotNetUtilityStruct (public fn IsInstanceOf typeName obj = (classOf typeName == String and classOf obj == DotNetObject and (DotNet.GetType typeName).IsInstanceOfType obj;),public fn IsSubclassOf typeName obj = (classOf typeName == String and (classOf obj == DotNetClass or classOf obj == DotNetObject) and (DotNet.GetType obj).IsSubclassOf (DotNet.GetType typeName);),public fn TypeOf obj = (if classOf obj == DotNetClass or classOf obj == DotNetObject then ((DotNet.GetType obj).FullName;);else ((classOf obj) as String;);),public fn StructName = #DotNetUtilityStruct,public fn Dump indent:"" out:listener = (format "%DotNetUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Easing.ms"] = struct EasingStruct (public fn BackIn v = (v = this.clamp v;v ^ 3 - v * sin (v * radToDeg ::pi);),public fn BackInOut v = (v = this.clamp v;if v < 0.5 then (local f = 2.0 * v;0.5 * (f ^ 3 - f * sin (f * radToDeg ::pi)););else (local f = 1.0 - (2.0 * v - 1.0);0.5 * (1.0 - (f ^ 3 - f * sin (f * radToDeg ::pi))) + 0.5;);),public fn BackOut v = (v = this.clamp v;local f = 1.0 - v;1.0 - (f ^ 3 - f * sin (f * radToDeg ::pi));),public fn Bezier v tangent1 tangent2 start:0.0 end:1.0 = (v = this.clamp v;local p1 = this.clamp [0.0, start];local p2 = this.clamp [tangent1.X, tangent1.Y];local p3 = this.clamp [tangent2.X, tangent2.Y];local p4 = this.clamp [1.0, end];local t = 0.0;if v <= p1.X then (t = 0.0;);else (if p4.X <= v then (t = 1.0;);else (local a = -p1.X + 3.0 * p2.X - 3.0 * p3.X + p4.X;local b = 3.0 * p1.X - 6.0 * p2.X + 3.0 * p3.X;local c = -3.0 * p1.X + 3.0 * p2.X;local d = p1.X - v;t = this.solveCubicEquation a b c d;););(1.0 - t) ^ 3 * p1.Y + 3.0 * (1.0 - t) ^ 2 * t * p2.Y + 3.0 * (1.0 - t) * t ^ 2 * p3.Y + t ^ 3 * p4.Y;),public fn BounceIn v = (v = 1.0 - (this.clamp v);if v < 4.0 / 11.0 then (1.0 - ((121.0 * v ^ 2) / 16.0););else (if v < 8.0 / 11.0 then (1.0 - ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0););else (if v < 9.0 / 10.0 then (1.0 - ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0););else (1.0 - ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0););););),public fn BounceInOut v = (v = this.clamp v;if v < 0.5 then (v = 1.0 - v * 2.0;if v < 4.0 / 11.0 then (0.5 * (1.0 - ((121.0 * v ^ 2) / 16.0)););else (if v < 8.0 / 11.0 then (0.5 * (1.0 - ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0)););else (if v < 9.0 / 10.0 then (0.5 * (1.0 - ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0)););else (0.5 * (1.0 - ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0));););););else (v = v * 2.0 - 1.0;if v < 4.0 / 11.0 then (0.5 * ((121.0 * v ^ 2) / 16.0) + 0.5;);else (if v < 8.0 / 11.0 then (0.5 * ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0) + 0.5;);else (if v < 9.0 / 10.0 then (0.5 * ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0) + 0.5;);else (0.5 * ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0) + 0.5;););););),public fn BounceOut v = (v = this.clamp v;if v < 4.0 / 11.0 then ((121.0 * v ^ 2) / 16.0;);else (if v < 8.0 / 11.0 then ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0;);else (if v < 9.0 / 10.0 then ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0;);else ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0;);););),public fn CircularIn v = (v = this.clamp v;1.0 - sqrt (1.0 - v ^ 2);),public fn CircularInOut v = (v = this.clamp v;if v < 0.5 then (0.5 * (1.0 - sqrt (1.0 - 4.0 * (v ^ 2))););else (0.5 * (sqrt (-(2.0 * v - 3.0) * (2.0 * v - 1.0)) + 1.0););),public fn CircularOut v = (v = this.clamp v;sqrt ((2.0 - v) * v);),public fn CubicIn v = (v = this.clamp v;v ^ 3;),public fn CubicInOut v = (v = this.clamp v;if v < 0.5 then (4.0 * (v ^ 3););else (4.0 * ((v - 1.0) ^ 3) + 1.0;);),public fn CubicOut v = (v = this.clamp v;(v - 1.0) ^ 3 + 1.0;),public fn ElasticIn v frequency:3 damping:10.0 flat:false = (v = this.clamp v;frequency = this.clamp frequency lower:0 high:100;damping = this.clamp damping lower:0.0 high:100.0;local f = frequency as Float * 2.0 + (if flat then 0.0 else 0.5);local s = sin (f * radToDeg ::pi * v);local d = 2.0 ^ (damping * (v - 1.0));s * d + (if flat then 1.0 else 0.0);),public fn ElasticInOut v frequency:3 damping:10.0 flat:false = (v = this.clamp v;frequency = this.clamp frequency lower:0 high:100;damping = this.clamp damping lower:0.0 high:100.0;local f = frequency as Float * 2.0 + (if flat then 0.0 else 0.5);if v < 0.5 then (local s = sin (f * radToDeg ::pi * (v * 2.0));local d = 2.0 ^ (damping * (v * 2.0 - 1.0));s * d * 0.5 + (if flat then 1.0 else 0.0););else (local s = sin (-f * (if flat then -1 else 1) * radToDeg ::pi * (v * 2.0 + (if flat then 1.0 else 0.0)));local d = 2.0 ^ (-damping * (v * 2.0 - 1.0));s * d * 0.5 + 1.0;);),public fn ElasticOut v frequency:3 damping:10.0 flat:false = (v = this.clamp v;frequency = this.clamp frequency lower:0 high:100;damping = this.clamp damping lower:0.0 high:100.0;local f = frequency as Float * 2.0 + (if flat then 0.0 else 0.5);local s = sin (-f * (if flat then -1 else 1) * radToDeg ::pi * (v + 1.0));local d = 2.0 ^ (-damping * v);s * d + 1.0;),public fn ExponentialIn v = (v = this.clamp v;case v of ((0.0): v;(1.0): v;default: 2.0 ^ (10.0 * (v - 1.0)););),public fn ExponentialInOut v = (v = this.clamp v;case v of ((0.0): v;(1.0): v;default: (if v < 0.5 then (2.0 ^ (10.0 * (2.0 * v - 1.0) - 1.0););else (1.0 - (2.0 ^ (-10.0 * (2.0 * v - 1.0) - 1.0)););););),public fn ExponentialOut v = (v = this.clamp v;case v of ((0.0): v;(1.0): v;default: -(2.0 ^ (-10.0 * v)) + 1.0;);),public fn Linear v = (this.clamp v;),public fn QuadraticIn v = (v = this.clamp v;v ^ 2;),public fn QuadraticInOut v = (v = this.clamp v;if v < 0.5 then (2.0 * (v ^ 2););else (1.0 - 2.0 * ((v - 1.0) ^ 2););),public fn QuadraticOut v = (v = this.clamp v;-v * (v - 2.0);),public fn QuarticIn v = (v = this.clamp v;v ^ 4;),public fn QuarticInOut v = (v = this.clamp v;if v < 0.5 then (8.0 * (v ^ 4););else (1.0 - 8.0 * ((v - 1.0) ^ 4););),public fn QuarticOut v = (v = this.clamp v;1.0 - (v - 1.0) ^ 4;),public fn QuinticIn v = (v = this.clamp v;v ^ 5;),public fn QuinticInOut v = (v = this.clamp v;if v < 0.5 then (16.0 * (v ^ 5););else (16.0 * ((v - 1.0) ^ 5) + 1.0;);),public fn QuinticOut v = (v = this.clamp v;(v - 1.0) ^ 5 + 1.0;),public fn Sigmoid v inflection slope = (v = this.clamp v;inflection = 0.5 + this.clamp inflection lower:-0.5 high:0.5;slope = 0.5 + this.clamp slope lower:-0.5 high:0.5;local c = (2.0 / (1.0 - slope * 0.8)) - 1.0;if v <= inflection then (if inflection == 0 then 0.0 else (v ^ c) / (inflection ^ (c - 1.0)););else ((1.0 - ((1.0 - v) ^ c) / ((1.0 - inflection) ^ (c - 1.0))););),public fn SineIn v = (v = this.clamp v;sin ((v - 1.0) * radToDeg ::pi / 2.0) + 1.0;),public fn SineInOut v = (v = this.clamp v;0.5 * (1.0 - cos (v * radTodeg ::pi));),public fn SineOut v = (v = this.clamp v;sin (v * radToDeg ::pi / 2.0);),private fn clamp input lower:0.0 high:1.0 = (case classOf input of ((Integer): (lower = lower as Integer;high = high as Integer;if input < lower do input = lower;if input > high do input = high;input;);(Float): (if input < lower do input = lower;if input > high do input = high;input;);(Point2): (if input.X < lower do input.X = lower;if input.Y < lower do input.Y = lower;if input.X > high do input.X = high;if input.Y > high do input.Y = high;input;);default: input;);),private fn isNormalized v = (0.0 <= v and v <= 1.0;),private fn solveCubicEquation a b c d = (local result = 0.0;if a == 0.0 then (result = this.solveQuadraticEquation b c d;);else (if d != 0.0 do (b /= a;c /= a;d /= a;local q = (3.0 * c - b ^ 2) / 9.0;local r = (-27.0 * d + b * (9.0 * c - 2.0 * (b ^ 2))) / 54.0;local discriminant = q ^ 3 + r ^ 2;local term1 = b / 3.0;if discriminant > 0.0 then (local s = r + sqrt discriminant;s = if s < 0.0 then -(-s ^ (1.0 / 3.0)) else s ^ (1.0 / 3.0);local t = r - sqrt discriminant;t = if t < 0.0 then -(-t ^ (1.0 / 3.0)) else t ^ (1.0 / 3.0);local x = -term1 + s + t;if this.isNormalized result do (result = x;););else (if discriminant == 0.0 then (local r13 = if r < 0.0 then -(-r ^ (1.0 / 3.0)) else r ^ (1.0 / 3.0);local x1 = -term1 + 2.0 * r13;local x2 = -(r13 + term1);if this.isNormalized x1 then (result = x1;);else (if this.isNormalized x2 do (result = x2;);););else (q = -q;local dum1 = q ^ 3;dum1 = acos (r / sqrt dum1);local r13 = 2.0 * sqrt q;local x1 = -term1 + r13 * cos (dum1 / 3.0);local x2 = -term1 + r13 * cos ((dum1 + 2.0 * radToDeg ::pi) / 3.0);local x3 = -term1 + r13 * cos ((dum1 + 4.0 * radToDeg ::pi) / 3.0);if this.isNormalized x1 then (result = x1;);else (if this.isNormalized x2 then (result = x2;);else (if this.isNormalized x3 do (result = x3;);););););););result;),private fn solveQuadraticEquation a b c = (local result = 0.0;local x1 = (-b + sqrt (b ^ 2 - 4.0 * a * c)) / 2.0 * a;local x2 = (-b - sqrt (b ^ 2 - 4.0 * a * c)) / 2.0 * a;if this.isNormalized x1 then (result = x1;);else (if this.isNormalized x2 do (result = x2;););result;),public fn StructName = #EasingStruct,public fn Dump indent:"" out:listener = (format "%EasingStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Observer.ms"] = struct ObserverStruct (public Callback,public Context,public fn StructName = #ObserverStruct,public fn Dump indent:"" out:listener = (format "%ObserverStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = isProperty obj #Callback and isProperty obj #Context and obj.Callback == this.Callback and obj.Context == this.Context;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"PathUtility.ms"] = struct PathUtilityStruct (public _CP1_,private baseDirectory,private directoryClass = DotNetClass "System.IO.Directory",private environmentClass = DotNetClass "System.Environment",private pathClass = DotNetClass "System.IO.Path",public fn ChangeExtension path extension = (this.pathClass.ChangeExtension path extension;),public fn ExtractDirectoryName path = (path = this.TrimEndSeparator path;if this.HasExtension path do (path = this.GetDirectoryName path;);path;),public fn GetBaseDirectory = (this.baseDirectory;),public fn GetDirectoryName path = (this.pathClass.GetDirectoryName path;),public fn GetExtension path = (this.pathClass.GetExtension path;),public fn GetFileName path = (this.pathClass.GetFileName path;),public fn GetFileNameWithoutExtension path = (this.pathClass.GetFileNameWithoutExtension path;),public fn GetFullPath path = (if this.directoryClass.Exists this.baseDirectory do (this.environmentClass.CurrentDirectory = this.baseDirectory;);this.pathClass.GetFullPath path;),public fn GetInvalidFileNameChars = (this.pathClass.GetInvalidFileNameChars();),public fn GetInvalidPathChars = (this.pathClass.GetInvalidPathChars();),public fn GetPathRoot path = (this.pathClass.GetPathRoot path;),public fn GetRandomFileName = (this.pathClass.GetRandomFileName();),public fn HasExtension path = (this.pathClass.HasExtension path;),public fn IsPathRooted path = (this.pathClass.IsPathRooted path;),public fn SetBaseDirectory path = (this.baseDirectory = path;if this.HasExtension this.baseDirectory do (this.baseDirectory = this.GetDirectoryName this.baseDirectory;);this.baseDirectory = this.TrimEndSeparator this.baseDirectory;this.GetBaseDirectory();),public fn TrimEndSeparator path = (if this.GetDirectoryName path != undefined and matchPattern path pattern:@"*\" do (path = trimRight path @"\";);path;),public fn StructName = #PathUtilityStruct,public fn Dump indent:"" out:listener = (format "%PathUtilityStruct\n" indent to:out;format "%  currentDir:@\"%\"\n" indent this.currentDir to:out;format "%  currentFile:@\"%\"\n" indent this.currentFile to:out;format "%  globalVarName:\"%\"\n" indent this.globalVarName to:out;format "%  parentDir:@\"%\"\n" indent this.parentDir to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (if classOf this._CP1_ == String then (this.SetBaseDirectory this._CP1_;);else (this.SetBaseDirectory (getSourceFileName()););););::standardDefinitionPool[@"ViewportUtility.ms"] = struct ViewportUtilityStruct (public fn GetDistancePerPixel = (1.0 / ((getViewSize()).Y / (getScreenScaleFactor [0, 0, 0]));),public fn PixelDistance v1 v2 = (local result = 0.0;if classOf v1 == Point3 and classOf v2 == Point3 do (local viewTM = getViewTM();local p1 = v1 * viewTM * [1, 1, 0];local p2 = v2 * viewTM * [1, 1, 0];local worldDist = distance p1 p2;result = worldDist / this.GetDistancePerPixel(););result;),public fn StructName = #ViewportUtilityStruct,public fn Dump indent:"" out:listener = (format "%ViewportUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Enum.ms"] = struct EnumStruct (public _CP1_,private baseEnumClass = DotNetClass "System.Enum",private dotNetUtility,private enumClass,public fn Create flagNames = (local enumObject = undefined;if this.IsValidEnum() do (for flagName in flagNames do (if isProperty this.enumClass flagName do (local flagObject = getProperty this.enumClass flagName;if enumObject == undefined then (enumObject = flagObject;);else (enumObject = DotNet.CombineEnums enumObject flagObject;););););enumObject;),public fn GetFlags enumObject = (local flagNames = this.GetNames();for flagName in flagNames collect (if this.HasFlag enumObject flagName then (flagName;);else (dontCollect;););),public fn GetNames = (local flagNames = #();if this.IsValidEnum() do (local propNames = this.baseEnumClass.GetNames this.enumClass;flagNames = for propName in propNames collect propName as Name;);flagNames;),public fn HasFlag enumObject flagName = (local result = false;if this.IsValidEnum() do (if isProperty this.enumClass flagName do (local flagObject = getProperty this.enumClass flagName;result = DotNet.CompareEnums enumObject flagObject;););result;),public fn IsValidEnum = (this.isEnumClass this.enumClass;),private fn isEnumClass obj = (this.dotNetUtility.IsSubclassOf "System.Enum" obj;),public fn StructName = #EnumStruct,public fn Dump indent:"" out:listener = (format "%EnumStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();if classOf this._CP1_ == String do (this.enumClass = DotNetClass this._CP1_;if not this.isEnumClass this.enumClass do (this.enumClass = undefined;););););::standardDefinitionPool[@"Timer.ms"] = struct TimerStruct (public _CP1_ = 100,private dotNetUtility,private ticks = 0,private timer,public fn GetInterval = (this.timer.Interval;),public fn GetTicks = (this.ticks;),public fn GetTimer = (this.timer;),public fn IsEnabled = (this.timer.Enabled;),public fn Reset = (this.Stop();this.ticks = 0;ok;),public fn Restart = (this.Reset();this.Start();ok;),public fn SetInterval input = (if input < 1 do input = 1;this.timer.Interval = input;this.notify #(#Interval);this.GetInterval();),public fn Start = (this.timer.Start();ok;),public fn Stop = (this.timer.Stop();ok;),public fn UpdateTicks = (this.ticks += 1;this.notify #(#Ticks);this.GetTicks();),public fn StructName = #TimerStruct,public fn Dump indent:"" out:listener = (format "%TimerStruct\n" indent to:out;format "%  ticks:%\n" indent this.ticks to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = isProperty obj #GetInterval and classOf obj.GetInterval == MAXScriptFunction and obj.GetInterval() == this.GetInterval() and isProperty obj #GetTicks and classOf obj.GetTicks == MAXScriptFunction and obj.GetTicks() == this.GetTicks() and isProperty obj #GetTimer and classOf obj.GetTimer == MAXScriptFunction;if isEqualProperties do (local ov = obj.GetTimer();local tv = this.GetTimer();isEqualProperties = this.dotNetUtility.IsInstanceOf "System.Windows.Forms.Timer" ov and ov.Equals tv;);isEqualStructName and isEqualProperties;),private observers = #(),public fn AddObserver observer = (if this.findObserver observer == 0 do (append this.observers observer;);this.findObserver observer > 0;),public fn RemoveObserver observer = (local index = this.findObserver observer;if index > 0 do (deleteItem this.observers index;);this.findObserver observer == 0;),private fn findObserver observer = (local index = 0;for i = 1 to this.observers.Count while index == 0 do (if this.observers[i].Equals observer do (index = i;););index;),private fn notify params type: = (for observer in this.observers do (observer.Callback observer.Context params type:type;);ok;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.timer = DotNetObject "System.Windows.Forms.Timer";if classOf this._CP1_ == Integer do (this.SetInterval this._CP1_;);this.timer.Tag = DotNetMxsValue this;DotNet.RemoveEventHandlers this.timer "Tick";DotNet.AddEventHandler this.timer "Tick" ::mxsDotNetTimerTickHandler;););::standardDefinitionPool[@"StringUtility.ms"] = struct StringUtilityStruct (private regexClass = DotNetClass "System.Text.RegularExpressions.Regex",private regexOptionsEnum,private stringClass = DotNetClass "System.String",private stringSplitOptionsEnum,private backslashRegex,private camelRegex,private commaRegex,private crRegex,private dotNetUtility,private doubleQuoteRegex,private enumDef,private formatRegex,private lfRegex,private nonWordRegex,private percentRegex,private tabRegex,public fn ClipString input digit:40 = (local result = copy input;if input.Count > digit do (result = substring result 1 (digit - 3) + "...";);result;),public fn CreateRegex pattern options:#(#IgnoreCase, #Singleline) = (if options.Count == 0 do (options = #(#None););local optionsObject = this.regexOptionsEnum.Create options;DotNetObject this.regexClass pattern optionsObject;),public fn EscapeBackslash input = (this.tabRegex.Replace (this.crRegex.Replace (this.lfRegex.Replace (this.doubleQuoteRegex.Replace (this.backslashRegex.Replace input "\\\\";) "\\\"";) "\\n";) "\\r";) "\\t";),public fn EscapeWhiteSpace input = (this.tabRegex.Replace (this.crRegex.Replace (this.lfRegex.Replace input "\\n";) "\\r";) "\\t";),public fn FormatString input values = (local result = copy input;local matches = this.formatRegex.Matches input;if matches.Count == values.Count do (for i = values.Count to 1 by -1 do (local index = matches.Item[i - 1].Index + 1;local replacement = case classOf values[i] of ((Name): this.ToPascalCase values[i];default: values[i] as String;);result = replace result index 1 replacement;);result = this.percentRegex.Replace result "%";);result;),public fn FromCodePoint codePoints = (local result = "";for cp in codePoints where floor cp 0 == cp do (local validCodePoints = this.GetValidUnicodeCodePoint cp;for vcp in validCodePoints do (result += Bit.IntAsChar vcp;););result;),public fn GetRegexOptions obj asStringArray:false = (local options = #();if this.IsRegexObject obj do (options = filterString (obj.Options.ToString()) ", ";sort options;if not asStringArray do (for i = 1 to options.Count do (options[i] = options[i] as Name;);););options;),public fn GetRegexPattern obj = (local pattern = "";if this.IsRegexObject obj do (pattern = this.EscapeWhiteSpace (obj.ToString()););pattern;),public fn GetUnicodeCodePointFromSurrogatePair highSurrogate lowSurrogate = (0x10000 + (Bit.Shift (highSurrogate - 0xD800) 10) + (lowSurrogate - 0xDC00);),public fn GetValidUnicodeCodePoint codePoint = (if codePoint <= 0xFFFF then (#(codePoint););else (codePoint -= 0x10000;#(0xD800 + Bit.Shift codePoint -10, 0xDC00 + Bit.And codePoint 0x3FF););),public fn IsRegexObject obj = (this.dotNetUtility.IsInstanceOf "System.Text.RegularExpressions.Regex" obj;),public fn Join input separator:"" = (this.stringClass.Join separator input;),public fn PadLeft input width char = ((DotNetObject this.stringClass input).PadLeft width char;),public fn PadRight input width char = ((DotNetObject this.stringClass input).PadRight width char;),public fn Split input separator removeEmpty:true = (local options = if removeEmpty then #(#RemoveEmptyEntries) else #(#None);local optionsObject = this.stringSplitOptionsEnum.Create options;(DotNetObject this.stringClass input).Split separator optionsObject;),public fn SplitByLF input = (this.lfRegex.Split input;),public fn ToCharArray input = ((DotNetObject this.stringClass input).ToCharArray();),public fn ToPascalCase input = (local result = "";case classOf input of ((Array): (result = "#(";for i = 1 to input.Count do (if i > 1 do (result += ", ";);local elementValue = this.ToPascalCase input[i];if classOf input[i] == String do (elementValue = "\"" + elementValue + "\"";);result += elementValue;);result += ")";);(BooleanClass): result = toLower (input as String);(DataPair): (local propNames = getPropNames input;local isExplicitPropNames = propNames.Count == 4;local v1Value = this.ToPascalCase input.V1;local v2Value = this.ToPascalCase input.V2;if classOf input.V1 == String do (v1Value = "\"" + v1Value + "\"";);if classOf input.V2 == String do (v2Value = "\"" + v2Value + "\"";);if isExplicitPropNames do (local v1Name = this.ToPascalCase propNames[3];local v2Name = this.ToPascalCase propNames[4];v1Name = (DotNetObject "System.String" v1Name).TrimStart "#";v2Name = (DotNetObject "System.String" v2Name).TrimStart "#";v1Value = v1Name + ":" + v1Value;v2Value = v2Name + ":" + v2Value;);result = "DataPair " + v1Value + " " + v2Value;);(OkClass): result = toLower (input as String);(UndefinedClass): result = toLower (input as String);(UnsuppliedClass): result = toLower (input as String);default: (result = input as String;local matches = this.camelRegex.Matches result;if matches.Count > 0 do (result = toLower result;for i = 1 to matches.Count do (local index = matches.Item[i - 1].Index + 1;result[index] = toUpper result[index];););if classOf input == Name do (if this.nonWordRegex.IsMatch result do (result = "'" + result + "'";);result = "#" + result;);););if not (classOf input == Name and classOf input == String) and this.commaRegex.IsMatch result do (result = this.commaRegex.Replace result ", ";);result;),public fn Trim input = ((DotNetObject this.stringClass input).Trim();),public fn TrimEnd input chars = ((DotNetObject this.stringClass input).TrimEnd chars;),public fn TrimStart input chars = ((DotNetObject this.stringClass input).TrimStart chars;),public fn StructName = #StringUtilityStruct,public fn Dump indent:"" out:listener = (format "%StringUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.enumDef = ::standardDefinitionPool[@"Enum.ms"];this.regexOptionsEnum = this.enumDef "System.Text.RegularExpressions.RegexOptions";this.stringSplitOptionsEnum = this.enumDef "System.StringSplitOptions";this.backslashRegex = this.CreateRegex "\\\\";this.camelRegex = this.CreateRegex "(?<=\b)\w|(?<=[a-z])[A-Z]|(?<=[0-9_])[a-z]" options:#();this.commaRegex = this.CreateRegex "\s*,\s*";this.crRegex = this.CreateRegex "\r";this.doubleQuoteRegex = this.CreateRegex "\\\"";this.formatRegex = this.CreateRegex "(?<!\\\\)%";this.lfRegex = this.CreateRegex "\n";this.nonWordRegex = this.CreateRegex "\W";this.percentRegex = this.CreateRegex "\\\\%";this.tabRegex = this.CreateRegex "\t";););::standardDefinitionPool[@"Encoding.ms"] = struct EncodingStruct (public _CP1_ = "utf-8",public _CP2_ = false,private allNames = #(),private bitConverterClass = DotNetClass "System.BitConverter",private convertClass = DotNetClass "System.Convert",private dotNetUtility,private encodingClass = DotNetClass "System.Text.Encoding",private encodingObject = DotNetObject "System.Text.UTF8Encoding" false,private hexStringRegex,private stringUtility,public fn DecodeHexString input = (local result = "";if this.IsValidEncoding() and this.hexStringRegex.IsMatch input do (local hexArray = filterString input "-";local bytes = for hex in hexArray collect this.convertClass.ToByte hex 16;result = this.GetString bytes;);result;),public fn EncodeToHexString input = (local result = "";if this.IsValidEncoding() do (result = this.bitConverterClass.ToString (this.GetBytes input););result;),public fn GetBytes input = (local bytes = #();if this.IsValidEncoding() do (bytes = this.encodingObject.GetBytes input;);bytes;),public fn GetCodePage = (local codePage = -1;if this.IsValidEncoding() do (codePage = this.encodingObject.CodePage;);codePage;),public fn GetDisplayName = (local displayName = "";if this.IsValidEncoding() do (displayName = this.encodingObject.EncodingName;);displayName;),public fn GetEncodingObject = (this.encodingObject;),public fn GetName = (local name = "";if this.IsValidEncoding() do (name = this.encodingObject.WebName;);name;),public fn GetString bytes = (local str = "";if this.IsValidEncoding() do (str = this.encodingObject.GetString bytes;);str;),public fn IsValidEncoding = (this.isEncodingSubclass this.encodingObject;),public fn SetEncoding name bom:false = (this.encodingObject = undefined;if this.isValidName name do (if stricmp name "utf-8" == 0 then (this.encodingObject = DotNetObject "System.Text.UTF8Encoding" bom;);else (this.encodingObject = this.encodingClass.GetEncoding name;););this.GetEncodingObject();),private fn isEncodingSubclass obj = (this.dotNetUtility.IsSubclassOf "System.Text.Encoding" obj;),private fn isValidName input = (findItem this.allNames (input as Name) > 0;),public fn StructName = #EncodingStruct,public fn Dump indent:"" out:listener = (format "%EncodingStruct\n" indent to:out;local typeName = this.dotNetUtility.TypeOf this.encodingObject;format "%  encodingObject:\"%\"\n" indent typeName to:out;if this.IsValidEncoding() do (format "%       CodePage:%\n" indent (this.GetCodePage()) to:out;format "%           Name:\"%\"\n" indent (this.GetName()) to:out;format "%    DisplayName:\"%\"\n" indent (this.GetDisplayName()) to:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.stringUtility = (::standardDefinitionPool[@"StringUtility.ms"])();this.hexStringRegex = this.stringUtility.CreateRegex "^([a-fA-F0-9]{2})?(\-[a-fA-F0-9]{2})*$";local encodingInfos = this.encodingClass.GetEncodings();this.allNames = for info in encodingInfos collect info.Name as Name;if classOf this._CP1_ == String and classOf this._CP2_ == BooleanClass do (this.SetEncoding this._CP1_ bom:this._CP2_;);););::standardDefinitionPool[@"FileUtility.ms"] = struct FileUtilityStruct (private comparer,private directoryClass = DotNetClass "System.IO.Directory",private directoryInfoClass = DotNetClass "System.IO.DirectoryInfo",private dotNetUtility,private encodingDef,private enumDef,private fileAttributesEnum,private fileClass = DotNetClass "System.IO.File",private pathUtility,private pathUtilityDef,private searchOptionEnum,public fn CopyDirectory source destination overwrite:false = (if this.DirectoryExists source and classOf destination == String do (destination = this.pathUtility.ExtractDirectoryName destination;this.copyDirectoryRecursive source destination overwrite;);ok;),public fn CopyFile source destination overwrite:false = (if this.FileExists source and classOf destination == String do (if overwrite or not this.FileExists destination do (this.fileClass.Copy source destination overwrite;););ok;),public fn CreateDirectory path = (this.directoryClass.CreateDirectory path;),public fn CreateTextFile path access:#Write encoding:"utf-8" bom:false = (local fs = this.fileClass.Create path;if this.dotNetUtility.IsInstanceOf "System.IO.FileStream" fs do (fs.Close(););this.OpenTextFile path access:access encoding:encoding bom:bom;),public fn DeleteDirectory path recursive:true = (if this.DirectoryExists path do (local subDirs = this.directoryClass.GetDirectories path;local subFiles = this.directoryClass.GetFiles path;if recursive or (subDirs.Count == 0 and subFiles.Count == 0) do (this.directoryClass.Delete path recursive;););),public fn DeleteFile path = (if this.FileExists path do (this.fileClass.Delete path;);ok;),public fn DirectoryExists path = (this.directoryClass.Exists path;),public fn EvaluateFile path = (if this.IsScriptFile path then (fileIn path;);else (undefined;);),public fn FileExists path = (this.fileClass.Exists path;),public fn GetCreationTime path asUtc:false = (local dateTimeObject = undefined;case this.getPathType path of ((#Directory): (if asUtc then (dateTimeObject = this.directoryClass.GetCreationTimeUtc path;);else (dateTimeObject = this.directoryClass.GetCreationTime path;););(#File): (if asUtc then (dateTimeObject = this.fileClass.GetCreationTimeUtc path;);else (dateTimeObject = this.fileClass.GetCreationTime path;););default: (););dateTimeObject;),public fn GetDirectories path pattern recursive:false = (local option = this.createSearchOption recursive;local dirs = this.directoryClass.GetDirectories path "*" option;qsort dirs this.comparer.CompareStringLogical;for dir in dirs collect (if matchPattern dir pattern:pattern ignoreCase:true then (dir;);else (dontCollect;););),public fn GetFiles path pattern recursive:false = (local option = this.createSearchOption recursive;local files = this.directoryClass.GetFiles path "*" option;qsort files this.comparer.CompareStringLogical;for file in files collect (if matchPattern file pattern:pattern ignoreCase:true then (file;);else (dontCollect;););),public fn GetLastAccessTime path asUtc:false = (local dateTimeObject = undefined;case this.getPathType path of ((#Directory): (if asUtc then (dateTimeObject = this.directoryClass.GetLastAccessTimeUtc path;);else (dateTimeObject = this.directoryClass.GetLastAccessTime path;););(#File): (if asUtc then (dateTimeObject = this.fileClass.GetLastAccessTimeUtc path;);else (dateTimeObject = this.fileClass.GetLastAccessTime path;););default: (););dateTimeObject;),public fn GetLastWriteTime path asUtc:false = (local dateTimeObject = undefined;case this.getPathType path of ((#Directory): (if asUtc then (dateTimeObject = this.directoryClass.GetLastWriteTimeUtc path;);else (dateTimeObject = this.directoryClass.GetLastWriteTime path;););(#File): (if asUtc then (dateTimeObject = this.fileClass.GetLastWriteTimeUtc path;);else (dateTimeObject = this.fileClass.GetLastWriteTime path;););default: (););dateTimeObject;),public fn GetMaxVersion path = (local version = 0;if this.IsMaxFile path do (version = (getMaxFileVersionData path)[1] / 1000 + 1998;);version;),public fn IsHidden path = (local attributesObject = this.getAttributes path;this.isFileAttributesObject attributesObject and this.fileAttributesEnum.HasFlag attributesObject #Hidden;),public fn IsMaxFile path = (this.FileExists path and ::isMaxFile path;),public fn IsReadOnly path = (local attributesObject = this.getAttributes path;this.isFileAttributesObject attributesObject and this.fileAttributesEnum.HasFlag attributesObject #ReadOnly;),public fn IsScriptFile path = (local extension = this.pathUtility.GetExtension path;this.FileExists path and stricmp extension ".ms" == 0;),public fn MoveDirectory source destination = (destination = this.pathUtility.ExtractDirectoryName destination;if this.DirectoryExists destination do (destination += @"\" + (this.pathUtility.GetFileName source);case this.getPathType source of ((#Directory): this.directoryClass.Move source destination;(#File): this.fileClass.Move source destination;default: ();););ok;),public fn OpenTextFile path access:#Read encoding:"utf-8" bom:false = (local fs = undefined;if this.FileExists path do (local modeValue = case access of ((#ReadWrite): "r+";(#Write): "wt";default: "rt";);local encodingObject = this.createEncoding encoding bom;local codePage = encodingObject.GetCodePage();fs = openFile path mode:modeValue encoding:codePage writeBOM:bom;);fs;),public fn ReadAllLines path encoding:"utf-8" bom:false = (local contents = undefined;if this.FileExists path do (local encodingObject = this.createEncoding encoding bom;contents = this.fileClass.ReadAllLines path (encodingObject.GetEncodingObject()););contents;),public fn ReadAllText path encoding:"utf-8" bom:false = (local contents = undefined;if this.FileExists path do (local encodingObject = this.createEncoding encoding bom;contents = this.fileClass.ReadAllText path (encodingObject.GetEncodingObject()););contents;),public fn RenameDirectory path newName = (if this.DirectoryExists path and classOf newName == String do (local dir = this.pathUtility.GetDirectoryName path;if classOf dir == String and this.DirectoryExists dir do (newName = this.pathUtility.GetFileNameWithoutExtension newName;local destination = dir + @"\" + newName;if not this.DirectoryExists destination do (this.directoryClass.Move path destination;);););ok;),public fn RenameFile path newName = (if this.FileExists path and classOf newName == String do (local dir = this.pathUtility.GetDirectoryName path;if classOf dir == String and this.DirectoryExists dir do (local destination = dir + @"\" + newName;if not this.pathUtility.HasExtension destination do (destination += this.pathUtility.GetExtension path;);if not this.FileExists destination do (this.fileClass.Move path destination;);););ok;),public fn WriteAllLines path contents eol:"\n" encoding:"utf-8" bom:false = (local ss = StringStream "";if classOf contents == Array do (with printAllElements true (for content in contents do (format "%%" content eol to:ss;);););this.WriteAllText path ss encoding:encoding bom:bom;ok;),public fn WriteAllText path contents encoding:"utf-8" bom:false = (if this.DirectoryExists (this.pathUtility.GetDirectoryName path) do (contents = contents as String;local encodingObject = this.createEncoding encoding bom;this.fileClass.WriteAllText path contents (encodingObject.GetEncodingObject()););ok;),private fn copyDirectoryRecursive source destination overwrite = (if not this.DirectoryExists destination do (local sourceInfo = this.createDirectoryInfo source;local destinationInfo = this.CreateDirectory destination;destinationInfo.Attributes = sourceInfo.Attributes;);if this.DirectoryExists destination do (local files = this.directoryClass.GetFiles source;for subSource in files do (local subDestination = copy destination;subDestination += @"\" + (this.pathUtility.GetFileName subSource);this.CopyFile subSource subDestination overwrite:overwrite;);local dirs = this.directoryClass.GetDirectories source;for subSource in dirs do (local subDestination = copy destination;subDestination += @"\" + (this.pathUtility.GetFileName subSource);this.copyDirectoryRecursive subSource subDestination overwrite;););ok;),private fn createDirectoryInfo path = (DotNetObject this.directoryInfoClass path;),private fn createEncoding encoding bom = (local encodingObject = this.encodingDef encoding bom;if not encodingObject.IsValidEncoding() do (encodingObject = this.encodingDef(););encodingObject;),private fn createSearchOption recursive = (if recursive then (this.searchOptionEnum.Create #(#AllDirectories););else (this.searchOptionEnum.Create #(#TopDirectoryOnly););),private fn getAttributes path = (local attributesObject = undefined;case this.getPathType path of ((#Directory): (attributesObject = (this.createDirectoryInfo path).Attributes;);(#File): (attributesObject = this.fileClass.GetAttributes path;);default: (););attributesObject;),private fn getPathType path = (if this.FileExists path then (#File;);else (if this.DirectoryExists path then (#Directory;);else (#Unknown;););),private fn isFileAttributesObject obj = (this.dotNetUtility.IsInstanceOf "System.IO.FileAttributes" obj;),public fn StructName = #FileUtilityStruct,public fn Dump indent:"" out:listener = (format "%FileUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.comparer = (::standardDefinitionPool[@"Comparer.ms"])();this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.encodingDef = ::standardDefinitionPool[@"Encoding.ms"];this.enumDef = ::standardDefinitionPool[@"Enum.ms"];this.pathUtilityDef = ::standardDefinitionPool[@"PathUtility.ms"];this.pathUtility = this.pathUtilityDef (getSourceFileName());this.fileAttributesEnum = this.enumDef "System.IO.FileAttributes";this.searchOptionEnum = this.enumDef "System.IO.SearchOption";););global std;struct StandardStruct (public AttributeUtility,public Comparer,public DotNetUtility,public EasingStruct,public EncodingStruct,public EnumStruct,public FileUtility,public ObserverStruct,public PathUtilityStruct,public StringUtility,public TimerStruct,public ViewportUtility,public fn Install = (::StandardStruct();if isProperty ::startupLoader #RegisterFile do (::startupLoader.RegisterFile (getSourceFileName()) installer:true;);format "[install]::std\n";ok;),public fn Uninstall = (if isProperty ::startupLoader #UnregisterFile do (::startupLoader.UnregisterFile (getSourceFileName()););::std = undefined;format "[uninstall]::std\n";ok;),private version = "1.0.0",public fn StructName = #StandardStruct,public fn Dump indent:"" out:listener = (format "%StandardStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),public fn GetVersion = (this.version;),on Create do (::std = this;this.AttributeUtility = (::standardDefinitionPool[@"AttributeUtility.ms"])();this.Comparer = (::standardDefinitionPool[@"Comparer.ms"])();this.DotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.EasingStruct = ::standardDefinitionPool[@"Easing.ms"];this.ObserverStruct = ::standardDefinitionPool[@"Observer.ms"];this.PathUtilityStruct = ::standardDefinitionPool[@"PathUtility.ms"];this.ViewportUtility = (::standardDefinitionPool[@"ViewportUtility.ms"])();this.EnumStruct = ::standardDefinitionPool[@"Enum.ms"];this.TimerStruct = ::standardDefinitionPool[@"Timer.ms"];this.StringUtility = (::standardDefinitionPool[@"StringUtility.ms"])();this.EncodingStruct = ::standardDefinitionPool[@"Encoding.ms"];this.FileUtility = (::standardDefinitionPool[@"FileUtility.ms"])();););::StandardStruct.Install();::StandardStruct
