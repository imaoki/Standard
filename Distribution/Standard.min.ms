/*! Â© 2022 imaoki | MIT License | https://github.com/imaoki */;global mxsDotNetTimerTickHandler = fn mxsDotNetTimerTickHandler sender event = (if classOf sender == DotNetObject and (DotNet.GetType "System.Windows.Forms.Timer").IsInstanceOfType sender do (if classOf sender.Tag == DotNetMxsValue do (local timerObject = sender.Tag.Value;if isStruct timerObject and isProperty timerObject #StructName and classOf timerObject.StructName == MAXScriptFunction and timerObject.StructName() == #TimerStruct do (timerObject.UpdateTicks(););););ok;);global standardDefinitionPool = Dictionary #String;::standardDefinitionPool[@"ArrayUtility.ms"] = struct ArrayUtilityStruct (public fn MoveItems items targetIndices destination = (local newIndices = #();if classOf items == Array and items.Count > 1 and classOf targetIndices == Array and classOf destination == Integer and destination > 0 do (local itemCount = items.Count;local itemIndices = #{1..itemCount} as Array;local targetCount = targetIndices.Count;if 1 <= targetCount and targetCount <= itemCount do (for i = targetCount to 1 by -1 do (local index = targetIndices[i];if index >= destination do (index += targetCount - i;);local item = items[index];local itemIndex = itemIndices[index];deleteItem items index;deleteItem itemIndices index;if index <= destination do (destination -= 1;);insertItem item items destination;insertItem itemIndex itemIndices destination;);newIndices = for i in targetIndices collect (findItem itemIndices i;);););newIndices;),public fn StructName = #ArrayUtilityStruct,public fn Dump indent:"" out:listener = (format "%ArrayUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"AttributeUtility.ms"] = struct AttributeUtilityStruct (public fn GetAttribute obj attributeName = (local attribute = undefined;if isValidObj obj do (local attributeCount = CustAttributes.Count obj baseObject:true;for i = 1 to attributeCount while attribute == undefined do (if (CustAttributes.GetDef obj i baseObject:true).Name == attributeName do (attribute = CustAttributes.Get obj i baseObject:true;);););attribute;),public fn GetAttributeNames obj = (local attributeNames = #();if isValidObj obj do (local attributeDefs = CustAttributes.GetDefs obj baseObject:true;if classOf attributeDefs == Array do (attributeNames = for def in attributeDefs collect def.Name;););attributeNames;),public fn HasAttribute obj attributeName = (this.IsAttribute (this.GetAttribute obj attributeName);),public fn IsAttribute obj = (superClassOf obj == AttributeDef;),public fn StructName = #AttributeUtilityStruct,public fn Dump indent:"" out:listener = (format "%AttributeUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Comparer.ms"] = struct ComparerStruct (private stringLogicalComparer,public fn CompareName a b = (if classOf a.Name == String and classOf b.Name == String then (this.CompareStringLogical a.Name b.Name;);else (this.simpleCompare a.Name b.Name;);),public fn CompareNodeHandle a b = (this.simpleCompare a.INode.Handle b.INode.Handle;),public fn CompareProperty a b propName: = (local aValue = getProperty a propName;local bValue = getProperty b propName;if classOf aValue == String and classOf bValue == String then (this.CompareStringLogical aValue bValue;);else (this.simpleCompare aValue bValue;);),public fn CompareStringLogical a b = (this.stringLogicalComparer a b;),private fn simpleCompare a b = (case of ((a < b): -1;(a > b): 1;default: 0;);),public fn StructName = #ComparerStruct,public fn Dump indent:"" out:listener = (format "%ComparerStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.stringLogicalComparer = (local code = StringStream "";format "using System;\n" to:code;format "using System.Collections;\n" to:code;format "using System.Runtime.InteropServices;\n" to:code;format "public sealed class StringLogicalComparer : IComparer {\n" to:code;format "  [DllImport(\"shlwapi.dll\", CharSet = CharSet.Unicode, ExactSpelling = true)]\n" to:code;format "  static extern int StrCmpLogicalW(String a, String b);\n" to:code;format "  public int Compare(object a, object b) {\n" to:code;format "    return StrCmpLogicalW((String)a, (String)b);\n" to:code;format "  }\n" to:code;format "}" to:code;code = code as String;local provider = DotNetObject "Microsoft.CSharp.CSharpCodeProvider";local params = DotNetObject "System.CodeDom.Compiler.CompilerParameters";params.GenerateInMemory = true;local compilerResults = provider.CompileAssemblyFromSource params #(code);local assembly = compilerResults.CompiledAssembly;(assembly.CreateInstance "StringLogicalComparer").Compare;);););::standardDefinitionPool[@"DotNetUtility.ms"] = struct DotNetUtilityStruct (public fn IsInstanceOf typeName obj = (classOf typeName == String and classOf obj == DotNetObject and (DotNet.GetType typeName).IsInstanceOfType obj;),public fn IsSubclassOf typeName obj = (classOf typeName == String and (classOf obj == DotNetClass or classOf obj == DotNetObject) and (DotNet.GetType obj).IsSubclassOf (DotNet.GetType typeName);),public fn TypeOf obj = (if classOf obj == DotNetClass or classOf obj == DotNetObject then ((DotNet.GetType obj).FullName;);else ((classOf obj) as String;);),public fn StructName = #DotNetUtilityStruct,public fn Dump indent:"" out:listener = (format "%DotNetUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Easing.ms"] = struct EasingStruct (public fn BackIn v = (v = this.clamp v;v ^ 3 - v * sin (v * radToDeg ::pi);),public fn BackInOut v = (v = this.clamp v;if v < 0.5 then (local f = 2.0 * v;0.5 * (f ^ 3 - f * sin (f * radToDeg ::pi)););else (local f = 1.0 - (2.0 * v - 1.0);0.5 * (1.0 - (f ^ 3 - f * sin (f * radToDeg ::pi))) + 0.5;);),public fn BackOut v = (v = this.clamp v;local f = 1.0 - v;1.0 - (f ^ 3 - f * sin (f * radToDeg ::pi));),public fn Bezier v tangent1 tangent2 start:0.0 end:1.0 = (v = this.clamp v;local p1 = this.clamp [0.0, start];local p2 = this.clamp [tangent1.X, tangent1.Y];local p3 = this.clamp [tangent2.X, tangent2.Y];local p4 = this.clamp [1.0, end];local t = 0.0;if v <= p1.X then (t = 0.0;);else (if p4.X <= v then (t = 1.0;);else (local a = -p1.X + 3.0 * p2.X - 3.0 * p3.X + p4.X;local b = 3.0 * p1.X - 6.0 * p2.X + 3.0 * p3.X;local c = -3.0 * p1.X + 3.0 * p2.X;local d = p1.X - v;t = this.solveCubicEquation a b c d;););(1.0 - t) ^ 3 * p1.Y + 3.0 * (1.0 - t) ^ 2 * t * p2.Y + 3.0 * (1.0 - t) * t ^ 2 * p3.Y + t ^ 3 * p4.Y;),public fn BounceIn v = (v = 1.0 - (this.clamp v);if v < 4.0 / 11.0 then (1.0 - ((121.0 * v ^ 2) / 16.0););else (if v < 8.0 / 11.0 then (1.0 - ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0););else (if v < 9.0 / 10.0 then (1.0 - ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0););else (1.0 - ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0););););),public fn BounceInOut v = (v = this.clamp v;if v < 0.5 then (v = 1.0 - v * 2.0;if v < 4.0 / 11.0 then (0.5 * (1.0 - ((121.0 * v ^ 2) / 16.0)););else (if v < 8.0 / 11.0 then (0.5 * (1.0 - ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0)););else (if v < 9.0 / 10.0 then (0.5 * (1.0 - ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0)););else (0.5 * (1.0 - ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0));););););else (v = v * 2.0 - 1.0;if v < 4.0 / 11.0 then (0.5 * ((121.0 * v ^ 2) / 16.0) + 0.5;);else (if v < 8.0 / 11.0 then (0.5 * ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0) + 0.5;);else (if v < 9.0 / 10.0 then (0.5 * ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0) + 0.5;);else (0.5 * ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0) + 0.5;););););),public fn BounceOut v = (v = this.clamp v;if v < 4.0 / 11.0 then ((121.0 * v ^ 2) / 16.0;);else (if v < 8.0 / 11.0 then ((363/40.0 * v ^ 2) - (99/10.0 * v) + 17.0 / 5.0;);else (if v < 9.0 / 10.0 then ((4356.0 / 361.0 * v ^ 2) - (35442.0 / 1805.0 * v) + 16061.0 / 1805.0;);else ((54.0 / 5.0 * v ^ 2) - (513.0 / 25.0 * v) + 268.0 / 25.0;);););),public fn CircularIn v = (v = this.clamp v;1.0 - sqrt (1.0 - v ^ 2);),public fn CircularInOut v = (v = this.clamp v;if v < 0.5 then (0.5 * (1.0 - sqrt (1.0 - 4.0 * (v ^ 2))););else (0.5 * (sqrt (-(2.0 * v - 3.0) * (2.0 * v - 1.0)) + 1.0););),public fn CircularOut v = (v = this.clamp v;sqrt ((2.0 - v) * v);),public fn CubicIn v = (v = this.clamp v;v ^ 3;),public fn CubicInOut v = (v = this.clamp v;if v < 0.5 then (4.0 * (v ^ 3););else (4.0 * ((v - 1.0) ^ 3) + 1.0;);),public fn CubicOut v = (v = this.clamp v;(v - 1.0) ^ 3 + 1.0;),public fn ElasticIn v frequency:3 damping:10.0 flat:false = (v = this.clamp v;frequency = this.clamp frequency lower:0 high:100;damping = this.clamp damping lower:0.0 high:100.0;local f = frequency as Float * 2.0 + (if flat then 0.0 else 0.5);local s = sin (f * radToDeg ::pi * v);local d = 2.0 ^ (damping * (v - 1.0));s * d + (if flat then 1.0 else 0.0);),public fn ElasticInOut v frequency:3 damping:10.0 flat:false = (v = this.clamp v;frequency = this.clamp frequency lower:0 high:100;damping = this.clamp damping lower:0.0 high:100.0;local f = frequency as Float * 2.0 + (if flat then 0.0 else 0.5);if v < 0.5 then (local s = sin (f * radToDeg ::pi * (v * 2.0));local d = 2.0 ^ (damping * (v * 2.0 - 1.0));s * d * 0.5 + (if flat then 1.0 else 0.0););else (local s = sin (-f * (if flat then -1 else 1) * radToDeg ::pi * (v * 2.0 + (if flat then 1.0 else 0.0)));local d = 2.0 ^ (-damping * (v * 2.0 - 1.0));s * d * 0.5 + 1.0;);),public fn ElasticOut v frequency:3 damping:10.0 flat:false = (v = this.clamp v;frequency = this.clamp frequency lower:0 high:100;damping = this.clamp damping lower:0.0 high:100.0;local f = frequency as Float * 2.0 + (if flat then 0.0 else 0.5);local s = sin (-f * (if flat then -1 else 1) * radToDeg ::pi * (v + 1.0));local d = 2.0 ^ (-damping * v);s * d + 1.0;),public fn ExponentialIn v = (v = this.clamp v;case v of ((0.0): v;(1.0): v;default: 2.0 ^ (10.0 * (v - 1.0)););),public fn ExponentialInOut v = (v = this.clamp v;case v of ((0.0): v;(1.0): v;default: (if v < 0.5 then (2.0 ^ (10.0 * (2.0 * v - 1.0) - 1.0););else (1.0 - (2.0 ^ (-10.0 * (2.0 * v - 1.0) - 1.0)););););),public fn ExponentialOut v = (v = this.clamp v;case v of ((0.0): v;(1.0): v;default: -(2.0 ^ (-10.0 * v)) + 1.0;);),public fn Linear v = (this.clamp v;),public fn QuadraticIn v = (v = this.clamp v;v ^ 2;),public fn QuadraticInOut v = (v = this.clamp v;if v < 0.5 then (2.0 * (v ^ 2););else (1.0 - 2.0 * ((v - 1.0) ^ 2););),public fn QuadraticOut v = (v = this.clamp v;-v * (v - 2.0);),public fn QuarticIn v = (v = this.clamp v;v ^ 4;),public fn QuarticInOut v = (v = this.clamp v;if v < 0.5 then (8.0 * (v ^ 4););else (1.0 - 8.0 * ((v - 1.0) ^ 4););),public fn QuarticOut v = (v = this.clamp v;1.0 - (v - 1.0) ^ 4;),public fn QuinticIn v = (v = this.clamp v;v ^ 5;),public fn QuinticInOut v = (v = this.clamp v;if v < 0.5 then (16.0 * (v ^ 5););else (16.0 * ((v - 1.0) ^ 5) + 1.0;);),public fn QuinticOut v = (v = this.clamp v;(v - 1.0) ^ 5 + 1.0;),public fn Sigmoid v inflection slope = (v = this.clamp v;inflection = 0.5 + this.clamp inflection lower:-0.5 high:0.5;slope = 0.5 + this.clamp slope lower:-0.5 high:0.5;local c = (2.0 / (1.0 - slope * 0.8)) - 1.0;if v <= inflection then (if inflection == 0 then 0.0 else (v ^ c) / (inflection ^ (c - 1.0)););else ((1.0 - ((1.0 - v) ^ c) / ((1.0 - inflection) ^ (c - 1.0))););),public fn SineIn v = (v = this.clamp v;sin ((v - 1.0) * radToDeg ::pi / 2.0) + 1.0;),public fn SineInOut v = (v = this.clamp v;0.5 * (1.0 - cos (v * radTodeg ::pi));),public fn SineOut v = (v = this.clamp v;sin (v * radToDeg ::pi / 2.0);),private fn clamp input lower:0.0 high:1.0 = (case classOf input of ((Integer): (lower = lower as Integer;high = high as Integer;if input < lower do input = lower;if input > high do input = high;input;);(Float): (if input < lower do input = lower;if input > high do input = high;input;);(Point2): (if input.X < lower do input.X = lower;if input.Y < lower do input.Y = lower;if input.X > high do input.X = high;if input.Y > high do input.Y = high;input;);default: input;);),private fn isNormalized v = (0.0 <= v and v <= 1.0;),private fn solveCubicEquation a b c d = (local result = 0.0;if a == 0.0 then (result = this.solveQuadraticEquation b c d;);else (if d != 0.0 do (b /= a;c /= a;d /= a;local q = (3.0 * c - b ^ 2) / 9.0;local r = (-27.0 * d + b * (9.0 * c - 2.0 * (b ^ 2))) / 54.0;local discriminant = q ^ 3 + r ^ 2;local term1 = b / 3.0;if discriminant > 0.0 then (local s = r + sqrt discriminant;s = if s < 0.0 then -(-s ^ (1.0 / 3.0)) else s ^ (1.0 / 3.0);local t = r - sqrt discriminant;t = if t < 0.0 then -(-t ^ (1.0 / 3.0)) else t ^ (1.0 / 3.0);local x = -term1 + s + t;if this.isNormalized result do (result = x;););else (if discriminant == 0.0 then (local r13 = if r < 0.0 then -(-r ^ (1.0 / 3.0)) else r ^ (1.0 / 3.0);local x1 = -term1 + 2.0 * r13;local x2 = -(r13 + term1);if this.isNormalized x1 then (result = x1;);else (if this.isNormalized x2 do (result = x2;);););else (q = -q;local dum1 = q ^ 3;dum1 = acos (r / sqrt dum1);local r13 = 2.0 * sqrt q;local x1 = -term1 + r13 * cos (dum1 / 3.0);local x2 = -term1 + r13 * cos ((dum1 + 2.0 * radToDeg ::pi) / 3.0);local x3 = -term1 + r13 * cos ((dum1 + 4.0 * radToDeg ::pi) / 3.0);if this.isNormalized x1 then (result = x1;);else (if this.isNormalized x2 then (result = x2;);else (if this.isNormalized x3 do (result = x3;);););););););result;),private fn solveQuadraticEquation a b c = (local result = 0.0;local x1 = (-b + sqrt (b ^ 2 - 4.0 * a * c)) / 2.0 * a;local x2 = (-b - sqrt (b ^ 2 - 4.0 * a * c)) / 2.0 * a;if this.isNormalized x1 then (result = x1;);else (if this.isNormalized x2 do (result = x2;););result;),public fn StructName = #EasingStruct,public fn Dump indent:"" out:listener = (format "%EasingStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Observable.ms"] = struct ObservableStruct (private observers = #(),public fn Count = (this.observers.Count;),public fn HasSubscribed obj = (this.findObserver obj > 0;),public fn Notify type param = (for observer in this.observers do (observer type param;);ok;),public fn Subscribe obj = (if this.findObserver obj == 0 do (append this.observers obj;);this.findObserver obj > 0;),public fn Unsubscribe obj = (local index = this.findObserver obj;if index > 0 do (deleteItem this.observers index;);this.findObserver obj <= 0;),private fn findObserver obj = (local index = -1;if this.isValidObserver obj do (index = 0;);for i = 1 to this.observers.Count while index == 0 do (if this.observers[i] == obj do (index = i;););index;),private fn isValidObserver obj = (classOf obj == MAXScriptFunction;),public fn StructName = #ObservableStruct,public fn Dump indent:"" out:listener = (format "%ObservableStruct\n" indent to:out;format "%  observers:%\n" indent this.observers.Count to:out;for i = 1 to this.observers.Count do (format "%    [%]:%\n" indent i this.observers[i] to:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"PathUtility.ms"] = struct PathUtilityStruct (public _CP1_,private baseDirectory,private directoryClass = DotNetClass "System.IO.Directory",private environmentClass = DotNetClass "System.Environment",private pathClass = DotNetClass "System.IO.Path",public fn ChangeExtension path extension = (this.pathClass.ChangeExtension path extension;),public fn GetBaseDirectory = (this.baseDirectory;),public fn GetDirectoryName path = (local directoryName = "";if classOf path == String and path.Count > 0 do (directoryName = this.pathClass.GetDirectoryName path;);directoryName;),public fn GetExtension path = (this.pathClass.GetExtension path;),public fn GetFileName path = (this.pathClass.GetFileName path;),public fn GetFileNameWithoutExtension path = (this.pathClass.GetFileNameWithoutExtension path;),public fn GetFullPath path = (local fullPath = "";if this.directoryClass.Exists this.baseDirectory do (this.environmentClass.CurrentDirectory = this.baseDirectory;);if classOf path == String and path.Count > 0 do (fullPath = this.pathClass.GetFullPath path;);fullPath;),public fn GetInvalidFileNameChars = (this.pathClass.GetInvalidFileNameChars();),public fn GetInvalidPathChars = (this.pathClass.GetInvalidPathChars();),public fn GetPathRoot path = (local pathRoot = "";if classOf path == String and path.Count > 0 do (pathRoot = this.pathClass.GetPathRoot path;);pathRoot;),public fn GetRandomFileName = (this.pathClass.GetRandomFileName();),public fn HasExtension path = (this.pathClass.HasExtension path;),public fn IsPathRooted path = (this.pathClass.IsPathRooted path;),public fn SetBaseDirectory path = (this.baseDirectory = path;if this.HasExtension this.baseDirectory do (this.baseDirectory = this.GetDirectoryName this.baseDirectory;);this.baseDirectory = this.TrimEndSeparator this.baseDirectory;this.GetBaseDirectory();),public fn TrimEndSeparator path = (if this.GetDirectoryName path != undefined and matchPattern path pattern:@"*\" do (path = trimRight path @"\";);path;),public fn StructName = #PathUtilityStruct,public fn Dump indent:"" out:listener = (format "%PathUtilityStruct\n" indent to:out;format "%  baseDirectory:@\"%\"\n" indent this.baseDirectory to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (if classOf this._CP1_ == String then (this.SetBaseDirectory this._CP1_;);else (this.SetBaseDirectory (getSourceFileName()););););::standardDefinitionPool[@"ViewportUtility.ms"] = struct ViewportUtilityStruct (public fn GetDistancePerPixel = (1.0 / ((getViewSize()).Y / (getScreenScaleFactor [0, 0, 0]));),public fn PixelDistance v1 v2 = (local result = 0.0;if classOf v1 == Point3 and classOf v2 == Point3 do (local viewTM = getViewTM();local p1 = v1 * viewTM * [1, 1, 0];local p2 = v2 * viewTM * [1, 1, 0];local worldDist = distance p1 p2;result = worldDist / this.GetDistancePerPixel(););result;),public fn StructName = #ViewportUtilityStruct,public fn Dump indent:"" out:listener = (format "%ViewportUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (););::standardDefinitionPool[@"Enum.ms"] = struct EnumStruct (public _CP1_,private baseEnumClass = DotNetClass "System.Enum",private dotNetUtility,private enumClass,public fn Create flagNames = (local enumObject = undefined;if this.IsValidEnum() do (for flagName in flagNames do (if isProperty this.enumClass flagName do (local flagObject = getProperty this.enumClass flagName;if enumObject == undefined then (enumObject = flagObject;);else (enumObject = DotNet.CombineEnums enumObject flagObject;););););enumObject;),public fn GetFlags enumObject = (local flagNames = this.GetNames();for flagName in flagNames collect (if this.HasFlag enumObject flagName then (flagName;);else (dontCollect;););),public fn GetNames = (local flagNames = #();if this.IsValidEnum() do (local propNames = this.baseEnumClass.GetNames this.enumClass;flagNames = for propName in propNames collect propName as Name;);flagNames;),public fn HasFlag enumObject flagName = (local result = false;if this.IsValidEnum() do (if isProperty this.enumClass flagName do (local flagObject = getProperty this.enumClass flagName;result = DotNet.CompareEnums enumObject flagObject;););result;),public fn IsValidEnum = (this.isEnumClass this.enumClass;),private fn isEnumClass obj = (this.dotNetUtility.IsSubclassOf "System.Enum" obj;),public fn StructName = #EnumStruct,public fn Dump indent:"" out:listener = (format "%EnumStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();if classOf this._CP1_ == String do (this.enumClass = DotNetClass this._CP1_;if not this.isEnumClass this.enumClass do (this.enumClass = undefined;););););::standardDefinitionPool[@"StringUtility.ms"] = struct StringUtilityStruct (private regexClass = DotNetClass "System.Text.RegularExpressions.Regex",private regexOptionsEnum,private stringClass = DotNetClass "System.String",private stringSplitOptionsEnum,private backslashRegex,private camelRegex,private commaRegex,private crRegex,private dotNetUtility,private doubleQuoteRegex,private enumDef,private formatRegex,private lfRegex,private nonWordRegex,private percentRegex,private tabRegex,public fn ClipString input digit:40 = (local result = copy input;if input.Count > digit do (result = substring result 1 (digit - 3) + "...";);result;),public fn CreateRegex pattern options:#(#IgnoreCase, #Singleline) = (if options.Count == 0 do (options = #(#None););local optionsObject = this.regexOptionsEnum.Create options;DotNetObject this.regexClass pattern optionsObject;),public fn EscapeBackslash input = (this.tabRegex.Replace (this.crRegex.Replace (this.lfRegex.Replace (this.doubleQuoteRegex.Replace (this.backslashRegex.Replace input "\\\\";) "\\\"";) "\\n";) "\\r";) "\\t";),public fn EscapeWhiteSpace input = (this.tabRegex.Replace (this.crRegex.Replace (this.lfRegex.Replace input "\\n";) "\\r";) "\\t";),public fn FormatString input values = (local result = copy input;local matches = this.formatRegex.Matches input;if matches.Count == values.Count do (for i = values.Count to 1 by -1 do (local index = matches.Item[i - 1].Index + 1;local replacement = case classOf values[i] of ((Name): this.ToPascalCase values[i];default: values[i] as String;);result = replace result index 1 replacement;);result = this.percentRegex.Replace result "%";);result;),public fn FromCodePoint codePoints = (local result = "";for cp in codePoints where floor cp 0 == cp do (local validCodePoints = this.GetValidUnicodeCodePoint cp;for vcp in validCodePoints do (result += Bit.IntAsChar vcp;););result;),public fn GetRegexOptions obj asStringArray:false = (local options = #();if this.IsRegexObject obj do (options = filterString (obj.Options.ToString()) ", ";sort options;if not asStringArray do (for i = 1 to options.Count do (options[i] = options[i] as Name;);););options;),public fn GetRegexPattern obj = (local pattern = "";if this.IsRegexObject obj do (pattern = this.EscapeWhiteSpace (obj.ToString()););pattern;),public fn GetUnicodeCodePointFromSurrogatePair highSurrogate lowSurrogate = (0x10000 + (Bit.Shift (highSurrogate - 0xD800) 10) + (lowSurrogate - 0xDC00);),public fn GetValidUnicodeCodePoint codePoint = (if codePoint <= 0xFFFF then (#(codePoint););else (codePoint -= 0x10000;#(0xD800 + Bit.Shift codePoint -10, 0xDC00 + Bit.And codePoint 0x3FF););),public fn IsRegexObject obj = (this.dotNetUtility.IsInstanceOf "System.Text.RegularExpressions.Regex" obj;),public fn Join input separator:"" = (this.stringClass.Join separator input;),public fn PadLeft input width char = ((DotNetObject this.stringClass input).PadLeft width char;),public fn PadRight input width char = ((DotNetObject this.stringClass input).PadRight width char;),public fn Serialize input = (local result = "";case classOf input of ((Array): (result = "#(";for i = 1 to input.Count do (if i > 1 do result += ", ";result += this.Serialize input[i];);result += ")";);(BigMatrix): (local rows = input.Rows as Integer;local cols = input.Columns as Integer;result = "(local _ = BigMatrix " + rows as String + " " + cols as String;for i = 1 to rows do (for j = 1 to cols do (result += ";_[" + i as String + "][" + j as String + "] = ";result += this.Serialize input[i][j];););result += ";_)";);(DataPair): (local propNames = getPropNames input;local isExplicitPropNames = propNames.Count == 4;local v1Value = this.Serialize input.V1;local v2Value = this.Serialize input.V2;if isExplicitPropNames do (local v1Name = this.TrimStart (this.ToPascalCase propNames[3]) "#";local v2Name = this.TrimStart (this.ToPascalCase propNames[4]) "#";v1Value = v1Name + ":" + v1Value;v2Value = v2Name + ":" + v2Value;);result = "(DataPair " + v1Value + " " + v2Value + ")";);(Dictionary): (result = "(Dictionary " + this.Serialize input.Type;for key in input.Keys do (local keyText = this.Serialize key;local valueText = this.Serialize input[key];result += " #(" + keyText + ", " + valueText + ")";);result += ")";);(Float): result += formattedPrint input format:"f";(String): result = "\"" + this.EscapeBackslash input + "\"";(StringStream): (result = "(StringStream " + this.Serialize (input as String) + ")";);default : result = this.ToPascalCase input;);if not (classOf input == Name or classOf input == String) and this.commaRegex.IsMatch result do (result = this.commaRegex.Replace result ", ";);result;),public fn Split input separator removeEmpty:true = (local options = if removeEmpty then #(#RemoveEmptyEntries) else #(#None);local optionsObject = this.stringSplitOptionsEnum.Create options;(DotNetObject this.stringClass input).Split separator optionsObject;),public fn SplitByLF input = (this.lfRegex.Split input;),public fn ToCharArray input = ((DotNetObject this.stringClass input).ToCharArray();),public fn ToPascalCase input = (local result = "";case classOf input of ((Array): (result = "#(";for i = 1 to input.Count do (if i > 1 do result += ", ";local elementValue = this.ToPascalCase input[i];if classOf input[i] == String do (elementValue = "\"" + elementValue + "\"";);result += elementValue;);result += ")";);(BigMatrix): (result = "#BigMatrix(";for i = 1 to input.Rows do (if i > 1 do result += ", ";result += "[";for j = 1 to input.Columns do (if j > 1 do result += ", ";result += input[i][j] as String;);result += "]";);result += ")";);(BooleanClass): result = toLower (input as String);(DataPair): (local propNames = getPropNames input;local isExplicitPropNames = propNames.Count == 4;local v1Value = this.ToPascalCase input.V1;local v2Value = this.ToPascalCase input.V2;if classOf input.V1 == String do (v1Value = "\"" + v1Value + "\"";);if classOf input.V2 == String do (v2Value = "\"" + v2Value + "\"";);if isExplicitPropNames do (local v1Name = this.TrimStart (this.ToPascalCase propNames[3]) "#";local v2Name = this.TrimStart (this.ToPascalCase propNames[4]) "#";v1Value = v1Name + ":" + v1Value;v2Value = v2Name + ":" + v2Value;);result = "(DataPair " + v1Value + " " + v2Value + ")";);(Dictionary): (result = "(Dictionary " + this.ToPascalCase input.Type;for key in input.Keys do (local keyText = this.ToPascalCase key;local valueText = this.ToPascalCase input[key];if classOf key == String do (keyText = "\"" + keyText + "\"";);if classOf input[key] == String do (valueText = "\"" + valueText + "\"";);result += " #(" + keyText + ", " + valueText + ")";);result += ")";);(Interval): (result = "(Interval";result += " " + toLower (input.Start as String);result += " " + toLower (input.End as String);result += ")";);(OkClass): result = toLower (input as String);(StringStream): (result = "(StringStream \"" + this.ToPascalCase (input as String) + "\")";);(Time): result = toLower (input as String);(UndefinedClass): result = toLower (input as String);(UnsuppliedClass): result = toLower (input as String);default: (result = input as String;local matches = this.camelRegex.Matches result;if matches.Count > 0 do (result = toLower result;for i = 1 to matches.Count do (local index = matches.Item[i - 1].Index + 1;result[index] = toUpper result[index];););if classOf input == Name do (if this.nonWordRegex.IsMatch result do (result = "'" + result + "'";);result = "#" + result;);););if not (classOf input == Name or classOf input == String) and this.commaRegex.IsMatch result do (result = this.commaRegex.Replace result ", ";);result;),public fn Trim input = ((DotNetObject this.stringClass input).Trim();),public fn TrimEnd input chars = ((DotNetObject this.stringClass input).TrimEnd chars;),public fn TrimStart input chars = ((DotNetObject this.stringClass input).TrimStart chars;),public fn StructName = #StringUtilityStruct,public fn Dump indent:"" out:listener = (format "%StringUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.enumDef = ::standardDefinitionPool[@"Enum.ms"];this.regexOptionsEnum = this.enumDef "System.Text.RegularExpressions.RegexOptions";this.stringSplitOptionsEnum = this.enumDef "System.StringSplitOptions";this.backslashRegex = this.CreateRegex "\\\\";this.camelRegex = this.CreateRegex "(?<=\b)\w|(?<=[a-z])[A-Z]|(?<=[0-9_])[a-z]" options:#();this.commaRegex = this.CreateRegex "\s*,\s*";this.crRegex = this.CreateRegex "\r";this.doubleQuoteRegex = this.CreateRegex "\\\"";this.formatRegex = this.CreateRegex "(?<!\\\\)%";this.lfRegex = this.CreateRegex "\n";this.nonWordRegex = this.CreateRegex "\W";this.percentRegex = this.CreateRegex "\\\\%";this.tabRegex = this.CreateRegex "\t";););::standardDefinitionPool[@"Encoding.ms"] = struct EncodingStruct (public _CP1_ = "utf-8",public _CP2_ = false,private allNames = #(),private bitConverterClass = DotNetClass "System.BitConverter",private convertClass = DotNetClass "System.Convert",private dotNetUtility,private encodingClass = DotNetClass "System.Text.Encoding",private encodingObject = DotNetObject "System.Text.UTF8Encoding" false,private hexStringRegex,private stringUtility,public fn DecodeHexString input = (local result = "";if this.IsValidEncoding() and this.hexStringRegex.IsMatch input do (local hexArray = filterString input "-";local bytes = for hex in hexArray collect this.convertClass.ToByte hex 16;result = this.GetString bytes;);result;),public fn EncodeToHexString input = (local result = "";if this.IsValidEncoding() do (result = this.bitConverterClass.ToString (this.GetBytes input););result;),public fn GetBytes input = (local bytes = #();if this.IsValidEncoding() do (bytes = this.encodingObject.GetBytes input;);bytes;),public fn GetCodePage = (local codePage = -1;if this.IsValidEncoding() do (codePage = this.encodingObject.CodePage;);codePage;),public fn GetDisplayName = (local displayName = "";if this.IsValidEncoding() do (displayName = this.encodingObject.EncodingName;);displayName;),public fn GetEncodingObject = (this.encodingObject;),public fn GetName = (local name = "";if this.IsValidEncoding() do (name = this.encodingObject.WebName;);name;),public fn GetString bytes = (local str = "";if this.IsValidEncoding() do (str = this.encodingObject.GetString bytes;);str;),public fn IsValidEncoding = (this.isEncodingSubclass this.encodingObject;),public fn SetEncoding name bom:false = (this.encodingObject = undefined;if this.isValidName name do (if stricmp name "utf-8" == 0 then (this.encodingObject = DotNetObject "System.Text.UTF8Encoding" bom;);else (this.encodingObject = this.encodingClass.GetEncoding name;););this.GetEncodingObject();),private fn isEncodingSubclass obj = (this.dotNetUtility.IsSubclassOf "System.Text.Encoding" obj;),private fn isValidName input = (findItem this.allNames (input as Name) > 0;),public fn StructName = #EncodingStruct,public fn Dump indent:"" out:listener = (format "%EncodingStruct\n" indent to:out;local typeName = this.dotNetUtility.TypeOf this.encodingObject;format "%  encodingObject:\"%\"\n" indent typeName to:out;if this.IsValidEncoding() do (format "%       CodePage:%\n" indent (this.GetCodePage()) to:out;format "%           Name:\"%\"\n" indent (this.GetName()) to:out;format "%    DisplayName:\"%\"\n" indent (this.GetDisplayName()) to:out;);ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.stringUtility = (::standardDefinitionPool[@"StringUtility.ms"])();this.hexStringRegex = this.stringUtility.CreateRegex "^([a-fA-F0-9]{2})?(\-[a-fA-F0-9]{2})*$";local encodingInfos = this.encodingClass.GetEncodings();this.allNames = for info in encodingInfos collect info.Name as Name;if classOf this._CP1_ == String and classOf this._CP2_ == BooleanClass do (this.SetEncoding this._CP1_ bom:this._CP2_;);););::standardDefinitionPool[@"Dialog.ms"] = struct DialogStruct (public _CP1_,public _CP2_ = [160, 160],public _CP3_,public _CP4_,private initPosition,private initSize = [160, 160],private lockHeight = false,private lockWidth = false,private menuDef,private modal = false,private rolloutDef,private styleBorder = false,private styleMaximizeBox = false,private styleMinimizeBox = false,private styleResizing = false,private styleSunkenedge = false,private styleSysmenu = true,private styleTitleBar = false,private styleToolWindow = true,public fn Create = (if this.isValidRolloutDef this.rolloutDef do (local w = this.initSize.X as Integer;local h = this.initSize.Y as Integer;local menu = unsupplied;if this.isValidMenuDef this.menuDef do (menu = this.menuDef;);local pos = unsupplied;if classOf this.initPosition == Point2 do (pos = this.initPosition;);local style = this.generateStyle();createDialog this.rolloutDef w h lockHeight:this.lockHeight lockWidth:this.lockWidth menu:menu modal:this.modal pos:pos style:style;this.StateChanged.Notify #DialogCreated undefined;);this.IsDisplayed();),public fn Destroy = (if this.inDialog this.rolloutDef do (destroyDialog this.rolloutDef;this.StateChanged.Notify #DialogDestroyed undefined;);not this.IsDisplayed();),public fn GetInitPosition = (this.initPosition;),public fn GetInitSize = (this.initSize;),public fn GetLockHeight = (this.lockHeight;),public fn GetLockWidth = (this.lockWidth;),public fn GetMenuDef = (this.menuDef;),public fn GetModal = (this.modal;),public fn GetPosition = (local pos = undefined;if this.isValidRolloutDef this.rolloutDef do (pos = getDialogPos this.rolloutDef;);pos;),public fn GetRolloutDef = (this.rolloutDef;),public fn GetRolloutName = (local rolloutName = undefined;if this.isValidRolloutDef this.rolloutDef do (rolloutName = this.rolloutDef.Name as Name;);rolloutName;),public fn GetSize = (local size = undefined;if this.isValidRolloutDef this.rolloutDef do (size = getDialogSize this.rolloutDef;);size;),public fn GetStyleBorder = (this.styleBorder;),public fn GetStyleMaximizeBox = (this.styleMaximizeBox;),public fn GetStyleMinimizeBox = (this.styleMinimizeBox;),public fn GetStyleResizing = (this.styleResizing;),public fn GetStyleSunkenedge = (this.styleSunkenedge;),public fn GetStyleSysmenu = (this.styleSysmenu;),public fn GetStyleTitleBar = (this.styleTitleBar;),public fn GetStyleToolWindow = (this.styleToolWindow;),public fn IsDisplayed = (this.inDialog this.rolloutDef;),public fn Load config = (local isSuccessful = false;if this.isValidConfig config do (local table = config.GetValue (this.generateConfigKey());if classOf table == Dictionary do (if hasDictValue table #InitPosition do this.initPosition = table[#InitPosition];if hasDictValue table #InitSize do this.initSize = table[#InitSize];if hasDictValue table #LockHeight do this.lockHeight = table[#LockHeight];if hasDictValue table #LockWidth do this.lockWidth = table[#LockWidth];if hasDictValue table #Modal do this.modal = table[#Modal];if hasDictValue table #StyleBorder do this.styleBorder = table[#StyleBorder];if hasDictValue table #StyleMaximizeBox do this.styleMaximizeBox = table[#StyleMaximizeBox];if hasDictValue table #StyleMinimizeBox do this.styleMinimizeBox = table[#StyleMinimizeBox];if hasDictValue table #StyleResizing do this.styleResizing = table[#StyleResizing];if hasDictValue table #StyleSunkenedge do this.styleSunkenedge = table[#StyleSunkenedge];if hasDictValue table #StyleSysmenu do this.styleSysmenu = table[#StyleSysmenu];if hasDictValue table #StyleTitleBar do this.styleTitleBar = table[#StyleTitleBar];if hasDictValue table #StyleToolWindow do this.styleToolWindow = table[#StyleToolWindow];isSuccessful = true;););isSuccessful;),public fn Save config = (local isSuccessful = false;if this.isValidConfig config do (local table = Dictionary #Name;table[#InitPosition] = this.initPosition;table[#InitSize] = this.initSize;table[#LockHeight] = this.lockHeight;table[#LockWidth] = this.lockWidth;table[#Modal] = this.modal;table[#StyleBorder] = this.styleBorder;table[#StyleMaximizeBox] = this.styleMaximizeBox;table[#StyleMinimizeBox] = this.styleMinimizeBox;table[#StyleResizing] = this.styleResizing;table[#StyleSunkenedge] = this.styleSunkenedge;table[#StyleSysmenu] = this.styleSysmenu;table[#StyleTitleBar] = this.styleTitleBar;table[#StyleToolWindow] = this.styleToolWindow;config.AddValue (this.generateConfigKey()) table;isSuccessful = true;);isSuccessful;),public fn SetInitPosition input = (if classOf input == Point2 or classOf input == UndefinedClass do (this.initPosition = input;this.StateChanged.Notify #InitPosition this.initPosition;);this.GetInitPosition();),public fn SetInitSize input = (if classOf input == Point2 do (this.initSize = input;this.StateChanged.Notify #InitSize this.initSize;);this.GetInitSize();),public fn SetLockHeight input = (if classOf input == BooleanClass do (this.lockHeight = input;this.StateChanged.Notify #LockHeight this.lockHeight;);this.GetLockHeight();),public fn SetLockWidth input = (if classOf input == BooleanClass do (this.lockWidth = input;this.StateChanged.Notify #LockWidth this.lockWidth;);this.GetLockWidth();),public fn SetMenuDef def = (if this.isValidMenuDef def or classOf def == UndefinedClass do (this.menuDef = def;this.StateChanged.Notify #MenuDef this.menuDef;);this.GetMenuDef();),public fn SetModal input = (if classOf input == BooleanClass do (this.modal = input;this.StateChanged.Notify #Modal this.modal;);this.GetModal();),public fn SetPosition input = (if classOf input == Point2 and this.inDialog this.rolloutDef do (setDialogPos this.rolloutDef input;this.StateChanged.Notify #PositionChanged undefined;);this.GetPosition();),public fn SetRolloutDef def = (if this.isValidRolloutDef def do (this.rolloutDef = def;this.StateChanged.Notify #RolloutDef this.rolloutDef;);this.GetRolloutDef();),public fn SetSize input = (if classOf input == Point2 and this.inDialog this.rolloutDef do (setDialogSize this.rolloutDef input;this.StateChanged.Notify #SizeChanged undefined;);this.GetSize();),public fn SetStyleBorder input = (if classOf input == BooleanClass do (this.styleBorder = input;this.StateChanged.Notify #StyleBorder this.styleBorder;);this.GetStyleBorder();),public fn SetStyleMaximizeBox input = (if classOf input == BooleanClass do (this.styleMaximizeBox = input;this.StateChanged.Notify #StyleMaximizeBox this.styleMaximizeBox;);this.GetStyleMaximizeBox();),public fn SetStyleMinimizeBox input = (if classOf input == BooleanClass do (this.styleMinimizeBox = input;this.StateChanged.Notify #StyleMinimizeBox this.styleMinimizeBox;);this.GetStyleMinimizeBox();),public fn SetStyleResizing input = (if classOf input == BooleanClass do (this.styleResizing = input;this.StateChanged.Notify #StyleResizing this.styleResizing;);this.GetStyleResizing();),public fn SetStyleSunkenedge input = (if classOf input == BooleanClass do (this.styleSunkenedge = input;this.StateChanged.Notify #StyleSunkenedge this.styleSunkenedge;);this.GetStyleSunkenedge();),public fn SetStyleSysmenu input = (if classOf input == BooleanClass do (this.styleSysmenu = input;this.StateChanged.Notify #StyleSysmenu this.styleSysmenu;);this.GetStyleSysmenu();),public fn SetStyleTitleBar input = (if classOf input == BooleanClass do (this.styleTitleBar = input;this.StateChanged.Notify #StyleTitleBar this.styleTitleBar;);this.GetStyleTitleBar();),public fn SetStyleToolWindow input = (if classOf input == BooleanClass do (this.styleToolWindow = input;this.StateChanged.Notify #StyleToolWindow this.styleToolWindow;);this.GetStyleToolWindow();),private fn generateConfigKey = (local rolloutKey = "";if this.isValidRolloutDef this.rolloutDef do (rolloutKey = this.rolloutDef.Name as String + ".";);(rolloutKey + "Dialog") as Name;),private fn generateStyle = (local style = #();if this.styleBorder do append style #Style_Border;if this.styleMaximizeBox do append style #Style_MaximizeBox;if this.styleMinimizeBox do append style #Style_MinimizeBox;if this.styleResizing do append style #Style_Resizing;if this.styleSunkenedge do append style #Style_Sunkenedge;if this.styleSysmenu do append style #Style_Sysmenu;if this.styleTitleBar do append style #Style_TitleBar;if this.styleToolWindow do append style #Style_ToolWindow;style;),private fn inDialog obj = (this.isValidRolloutDef obj and obj.InDialog;),private fn isValidConfig obj = (isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == #ConfigStruct;),private fn isValidMenuDef obj = ((classOf obj as String) as Name == #RCMenu;),private fn isValidRolloutDef obj = (classOf obj == RolloutClass;),public fn StructName = #DialogStruct,public fn Dump indent:"" out:listener = (format "%DialogStruct\n" indent to:out;format "%  initPosition:%\n" indent this.initPosition to:out;format "%  initSize:%\n" indent this.initSize to:out;format "%  menuDef:%\n" indent this.menuDef to:out;format "%  rolloutDef:%\n" indent this.rolloutDef to:out;format "%  styleBorder:%\n" indent this.styleBorder to:out;format "%  styleMaximizeBox:%\n" indent this.styleMaximizeBox to:out;format "%  styleMinimizeBox:%\n" indent this.styleMinimizeBox to:out;format "%  styleResizing:%\n" indent this.styleResizing to:out;format "%  styleSunkenedge:%\n" indent this.styleSunkenedge to:out;format "%  styleSysmenu:%\n" indent this.styleSysmenu to:out;format "%  styleTitleBar:%\n" indent this.styleTitleBar to:out;format "%  styleToolWindow:%\n" indent this.styleToolWindow to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),public StateChanged,on Create do (this.StateChanged = (::standardDefinitionPool[@"Observable.ms"])();this.SetRolloutDef this._CP1_;this.SetInitSize this._CP2_;this.SetInitPosition this._CP3_;this.SetMenuDef this._CP4_;););::standardDefinitionPool[@"Timer.ms"] = struct TimerStruct (public _CP1_ = 100,private dotNetUtility,private ticks = 0,private timer,public fn GetInterval = (this.timer.Interval;),public fn GetTicks = (this.ticks;),public fn GetTimer = (this.timer;),public fn IsEnabled = (this.timer.Enabled;),public fn Reset = (this.Stop();this.ticks = 0;ok;),public fn Restart = (this.Reset();this.Start();ok;),public fn SetInterval input = (if input < 1 do input = 1;this.timer.Interval = input;this.StateChanged.Notify #Interval this.timer.Interval;this.GetInterval();),public fn Start = (this.timer.Start();ok;),public fn Stop = (this.timer.Stop();ok;),public fn UpdateTicks = (this.ticks += 1;this.StateChanged.Notify #Ticks this;this.GetTicks();),public fn StructName = #TimerStruct,public fn Dump indent:"" out:listener = (format "%TimerStruct\n" indent to:out;format "%  ticks:%\n" indent this.ticks to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = isProperty obj #GetInterval and classOf obj.GetInterval == MAXScriptFunction and obj.GetInterval() == this.GetInterval() and isProperty obj #GetTicks and classOf obj.GetTicks == MAXScriptFunction and obj.GetTicks() == this.GetTicks() and isProperty obj #GetTimer and classOf obj.GetTimer == MAXScriptFunction;if isEqualProperties do (local ov = obj.GetTimer();local tv = this.GetTimer();isEqualProperties = this.dotNetUtility.IsInstanceOf "System.Windows.Forms.Timer" ov and ov.Equals tv;);isEqualStructName and isEqualProperties;),public StateChanged,on Create do (this.StateChanged = (::standardDefinitionPool[@"Observable.ms"])();this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.timer = DotNetObject "System.Windows.Forms.Timer";if classOf this._CP1_ == Integer do (this.SetInterval this._CP1_;);this.timer.Tag = DotNetMxsValue this;DotNet.RemoveEventHandlers this.timer "Tick";DotNet.AddEventHandler this.timer "Tick" ::mxsDotNetTimerTickHandler;););::standardDefinitionPool[@"FileUtility.ms"] = struct FileUtilityStruct (private comparer,private directoryClass = DotNetClass "System.IO.Directory",private directoryInfoClass = DotNetClass "System.IO.DirectoryInfo",private dotNetUtility,private encodingDef,private enumDef,private fileAttributesEnum,private fileClass = DotNetClass "System.IO.File",private pathUtility,private pathUtilityDef,private searchOptionEnum,public fn CopyDirectory source destination overwrite:false = (if this.DirectoryExists source and classOf destination == String do (destination = this.pathUtility.TrimEndSeparator destination;this.copyDirectoryRecursive source destination overwrite;);ok;),public fn CopyFile source destination overwrite:false = (if this.FileExists source and classOf destination == String do (if overwrite or not this.FileExists destination do (this.fileClass.Copy source destination overwrite;););ok;),public fn CreateDirectory path = (this.directoryClass.CreateDirectory path;),public fn CreateTextFile path access:#Write encoding:"utf-8" bom:false = (local fs = this.fileClass.Create path;if this.dotNetUtility.IsInstanceOf "System.IO.FileStream" fs do (fs.Close(););this.OpenTextFile path access:access encoding:encoding bom:bom;),public fn DeleteDirectory path recursive:true = (if this.DirectoryExists path do (local subDirs = this.directoryClass.GetDirectories path;local subFiles = this.directoryClass.GetFiles path;if recursive or (subDirs.Count == 0 and subFiles.Count == 0) do (this.directoryClass.Delete path recursive;););),public fn DeleteFile path = (if this.FileExists path do (this.fileClass.Delete path;);ok;),public fn DirectoryExists path = (this.directoryClass.Exists path;),public fn EvaluateFile path = (if this.IsScriptFile path then (fileIn path;);else (undefined;);),public fn FileExists path = (this.fileClass.Exists path;),public fn GetCreationTime path asUtc:false = (local dateTimeObject = undefined;case this.getPathType path of ((#Directory): (if asUtc then (dateTimeObject = this.directoryClass.GetCreationTimeUtc path;);else (dateTimeObject = this.directoryClass.GetCreationTime path;););(#File): (if asUtc then (dateTimeObject = this.fileClass.GetCreationTimeUtc path;);else (dateTimeObject = this.fileClass.GetCreationTime path;););default: (););dateTimeObject;),public fn GetDirectories path pattern recursive:false = (local option = this.createSearchOption recursive;local dirs = this.directoryClass.GetDirectories path "*" option;qsort dirs this.comparer.CompareStringLogical;for dir in dirs collect (if matchPattern dir pattern:pattern ignoreCase:true then (dir;);else (dontCollect;););),public fn GetFiles path pattern recursive:false = (local option = this.createSearchOption recursive;local files = this.directoryClass.GetFiles path "*" option;qsort files this.comparer.CompareStringLogical;for file in files collect (if matchPattern file pattern:pattern ignoreCase:true then (file;);else (dontCollect;););),public fn GetLastAccessTime path asUtc:false = (local dateTimeObject = undefined;case this.getPathType path of ((#Directory): (if asUtc then (dateTimeObject = this.directoryClass.GetLastAccessTimeUtc path;);else (dateTimeObject = this.directoryClass.GetLastAccessTime path;););(#File): (if asUtc then (dateTimeObject = this.fileClass.GetLastAccessTimeUtc path;);else (dateTimeObject = this.fileClass.GetLastAccessTime path;););default: (););dateTimeObject;),public fn GetLastWriteTime path asUtc:false = (local dateTimeObject = undefined;case this.getPathType path of ((#Directory): (if asUtc then (dateTimeObject = this.directoryClass.GetLastWriteTimeUtc path;);else (dateTimeObject = this.directoryClass.GetLastWriteTime path;););(#File): (if asUtc then (dateTimeObject = this.fileClass.GetLastWriteTimeUtc path;);else (dateTimeObject = this.fileClass.GetLastWriteTime path;););default: (););dateTimeObject;),public fn GetMaxVersion path = (local version = 0;if this.IsMaxFile path do (version = (getMaxFileVersionData path)[1] / 1000 + 1998;);version;),public fn IsHidden path = (local attributesObject = this.getAttributes path;this.isFileAttributesObject attributesObject and this.fileAttributesEnum.HasFlag attributesObject #Hidden;),public fn IsMaxFile path = (this.FileExists path and ::isMaxFile path;),public fn IsReadOnly path = (local attributesObject = this.getAttributes path;this.isFileAttributesObject attributesObject and this.fileAttributesEnum.HasFlag attributesObject #ReadOnly;),public fn IsScriptFile path = (local extension = this.pathUtility.GetExtension path;this.FileExists path and stricmp extension ".ms" == 0;),public fn MoveDirectory source destination = (destination = this.pathUtility.TrimEndSeparator destination;if this.DirectoryExists destination do (destination += @"\" + (this.pathUtility.GetFileName source);case this.getPathType source of ((#Directory): this.directoryClass.Move source destination;(#File): this.fileClass.Move source destination;default: ();););ok;),public fn OpenTextFile path access:#Read encoding:"utf-8" bom:false = (local fs = undefined;if this.FileExists path do (local modeValue = case access of ((#ReadWrite): "r+";(#Write): "wt";default: "rt";);local encodingObject = this.createEncoding encoding bom;local codePage = encodingObject.GetCodePage();fs = openFile path mode:modeValue encoding:codePage writeBOM:bom;);fs;),public fn ReadAllLines path encoding:"utf-8" bom:false = (local contents = undefined;if this.FileExists path do (local encodingObject = this.createEncoding encoding bom;contents = this.fileClass.ReadAllLines path (encodingObject.GetEncodingObject()););contents;),public fn ReadAllText path encoding:"utf-8" bom:false = (local contents = undefined;if this.FileExists path do (local encodingObject = this.createEncoding encoding bom;contents = this.fileClass.ReadAllText path (encodingObject.GetEncodingObject()););contents;),public fn RenameDirectory path newName = (if this.DirectoryExists path and classOf newName == String do (local dir = this.pathUtility.GetDirectoryName path;if classOf dir == String and this.DirectoryExists dir do (newName = this.pathUtility.GetFileNameWithoutExtension newName;local destination = dir + @"\" + newName;if not this.DirectoryExists destination do (this.directoryClass.Move path destination;);););ok;),public fn RenameFile path newName = (if this.FileExists path and classOf newName == String do (local dir = this.pathUtility.GetDirectoryName path;if classOf dir == String and this.DirectoryExists dir do (local destination = dir + @"\" + newName;if not this.pathUtility.HasExtension destination do (destination += this.pathUtility.GetExtension path;);if not this.FileExists destination do (this.fileClass.Move path destination;);););ok;),public fn WriteAllLines path contents eol:"\n" encoding:"utf-8" bom:false = (local ss = StringStream "";if classOf contents == Array do (with printAllElements true (for content in contents do (format "%%" content eol to:ss;);););this.WriteAllText path ss encoding:encoding bom:bom;ok;),public fn WriteAllText path contents encoding:"utf-8" bom:false = (if this.DirectoryExists (this.pathUtility.GetDirectoryName path) do (contents = contents as String;local encodingObject = this.createEncoding encoding bom;this.fileClass.WriteAllText path contents (encodingObject.GetEncodingObject()););ok;),private fn copyDirectoryRecursive source destination overwrite = (if not this.DirectoryExists destination do (local sourceInfo = this.createDirectoryInfo source;local destinationInfo = this.CreateDirectory destination;destinationInfo.Attributes = sourceInfo.Attributes;);if this.DirectoryExists destination do (local files = this.directoryClass.GetFiles source;for subSource in files do (local subDestination = copy destination;subDestination += @"\" + (this.pathUtility.GetFileName subSource);this.CopyFile subSource subDestination overwrite:overwrite;);local dirs = this.directoryClass.GetDirectories source;for subSource in dirs do (local subDestination = copy destination;subDestination += @"\" + (this.pathUtility.GetFileName subSource);this.copyDirectoryRecursive subSource subDestination overwrite;););ok;),private fn createDirectoryInfo path = (DotNetObject this.directoryInfoClass path;),private fn createEncoding encoding bom = (local encodingObject = this.encodingDef encoding bom;if not encodingObject.IsValidEncoding() do (encodingObject = this.encodingDef(););encodingObject;),private fn createSearchOption recursive = (if recursive then (this.searchOptionEnum.Create #(#AllDirectories););else (this.searchOptionEnum.Create #(#TopDirectoryOnly););),private fn getAttributes path = (local attributesObject = undefined;case this.getPathType path of ((#Directory): (attributesObject = (this.createDirectoryInfo path).Attributes;);(#File): (attributesObject = this.fileClass.GetAttributes path;);default: (););attributesObject;),private fn getPathType path = (if this.FileExists path then (#File;);else (if this.DirectoryExists path then (#Directory;);else (#Unknown;););),private fn isFileAttributesObject obj = (this.dotNetUtility.IsInstanceOf "System.IO.FileAttributes" obj;),public fn StructName = #FileUtilityStruct,public fn Dump indent:"" out:listener = (format "%FileUtilityStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.comparer = (::standardDefinitionPool[@"Comparer.ms"])();this.dotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.encodingDef = ::standardDefinitionPool[@"Encoding.ms"];this.enumDef = ::standardDefinitionPool[@"Enum.ms"];this.pathUtilityDef = ::standardDefinitionPool[@"PathUtility.ms"];this.pathUtility = this.pathUtilityDef (getSourceFileName());this.fileAttributesEnum = this.enumDef "System.IO.FileAttributes";this.searchOptionEnum = this.enumDef "System.IO.SearchOption";););::standardDefinitionPool[@"Config.ms"] = struct ConfigStruct (public _CP1_,private filePath,private table,private dateTimeClass = DotNetClass "System.DateTime",private fileUtility,private pathUtility,private stringUtility,public fn AddValue key v = (if classOf key == Name do (this.table[key] = v;);this.HasValue key;),public fn Clear = (free this.table;ok;),public fn Count = (this.table.Count;),public fn GetFilePath = (this.filePath;),public fn GetKeys = (sort (copy this.table.Keys #NoMap);),public fn GetValue key default:undefined = (if this.HasValue key then (this.table[key];);else (default;);),public fn HasValue key = (classOf key == Name and hasDictValue this.table key;),public fn Read = (local isSuccessful = false;if this.isValidFilePath this.filePath and this.fileUtility.FileExists this.filePath do (local pattern = "* ?/\n(Dictionary #Name *";local content = this.fileUtility.ReadAllText this.filePath;if classOf content == String and matchPattern content pattern:pattern ignoreCase:true do (this.table = execute content;isSuccessful = true;););isSuccessful;),public fn SetFilePath input = (if this.isValidFilePath input do (local dirName = this.pathUtility.GetDirectoryName input;local fileNameWE = this.pathUtility.GetFileNameWithoutExtension input;this.filePath = dirName + @"\" + fileNameWE + ".mxsconfig";);this.GetFilePath();),public fn Write = (local isSuccessful = false;if this.isValidFilePath this.filePath then (local content = StringStream "";local now = this.dateTimeClass.Now.ToString "yyyy/MM/dd HH:mm:ss K";format "/* Generated by ConfigStruct at % */\n" now to:content;format "%\n" (this.stringUtility.Serialize this.table) to:content;content = content as String;this.fileUtility.WriteAllText this.filePath content;isSuccessful = this.fileUtility.FileExists this.filePath;);isSuccessful;),private fn isValidFilePath obj = (classOf obj == String and this.pathUtility.HasExtension obj;),public fn StructName = #ConfigStruct,public fn Dump indent:"" out:listener = (format "%ConfigStruct\n" indent to:out;if classOf this.filePath == String then (format "%  filePath:@\"%\"\n" indent this.filePath to:out;);else (format "%  filePath:%\n" indent this.filePath to:out;);format "%  table:%\n" indent (this.stringUtility.Serialize this.table) to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),on Create do (this.fileUtility = (::standardDefinitionPool[@"FileUtility.ms"])();this.pathUtility = (::standardDefinitionPool[@"PathUtility.ms"]) (getSourceFileName());this.stringUtility = (::standardDefinitionPool[@"StringUtility.ms"])();this.table = Dictionary #Name;this.SetFilePath this._CP1_;););global std;struct StandardStruct (public ArrayUtility,public AttributeUtility,public Comparer,public ConfigStruct,public DialogStruct,public DotNetUtility,public EasingStruct,public EncodingStruct,public EnumStruct,public FileUtility,public ObservableStruct,public PathUtilityStruct,public StringUtility,public TimerStruct,public ViewportUtility,public fn Install = (::StandardStruct();if isProperty ::startupLoader #RegisterFile do (::startupLoader.RegisterFile (getSourceFileName()););format "[install]::std\n";ok;),public fn Uninstall = (if isProperty ::startupLoader #UnregisterFile do (::startupLoader.UnregisterFile (getSourceFileName()););::std = undefined;format "[uninstall]::std\n";ok;),private version = #(2, 9, 1),public fn StructName = #StandardStruct,public fn Dump indent:"" out:listener = (format "%StandardStruct\n" indent to:out;ok;),public fn Equals obj = (local isEqualStructName = isStruct obj and isProperty obj #StructName and classOf obj.StructName == MAXScriptFunction and obj.StructName() == this.StructName();local isEqualProperties = true;isEqualStructName and isEqualProperties;),public fn GetVersion = (this.version;),on Create do (::std = this;this.ArrayUtility = (::standardDefinitionPool[@"ArrayUtility.ms"])();this.AttributeUtility = (::standardDefinitionPool[@"AttributeUtility.ms"])();this.Comparer = (::standardDefinitionPool[@"Comparer.ms"])();this.DialogStruct = ::standardDefinitionPool[@"Dialog.ms"];this.DotNetUtility = (::standardDefinitionPool[@"DotNetUtility.ms"])();this.EasingStruct = ::standardDefinitionPool[@"Easing.ms"];this.ObservableStruct = ::standardDefinitionPool[@"Observable.ms"];this.PathUtilityStruct = ::standardDefinitionPool[@"PathUtility.ms"];this.ViewportUtility = (::standardDefinitionPool[@"ViewportUtility.ms"])();this.EnumStruct = ::standardDefinitionPool[@"Enum.ms"];this.TimerStruct = ::standardDefinitionPool[@"Timer.ms"];this.StringUtility = (::standardDefinitionPool[@"StringUtility.ms"])();this.EncodingStruct = ::standardDefinitionPool[@"Encoding.ms"];this.FileUtility = (::standardDefinitionPool[@"FileUtility.ms"])();this.ConfigStruct = ::standardDefinitionPool[@"Config.ms"];););::StandardStruct.Install();::StandardStruct;